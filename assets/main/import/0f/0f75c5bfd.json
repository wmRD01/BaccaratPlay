[1,["58yCuwHsFH1qlNTJADPxpv","20g1ukYUVPvKWKBRznAKo+@f9941","8alTtAupxNEo2P97mR7FvF@f9941","aa8BK8wMFKA5ehC7Re7F3r","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","077uUy6eVAuZnt1J/ZFqj8@f9941","69Yvl5MgZJpIzYBSIQ5iCK@f9941","7dj5uJT9FMn6OrOOx83tfK@f9941","65YDJRyypPWKaEB5GtMZFf@f9941","71GEFzvI1Ijqd90EeqRHYX@f9941","83zSB9F1dCH5Nq4NgKJCAA","2a9EYeAqtHC6hAawpGjhPB@f9941","66oB8lGqlBsaOGycP6bbVf","c4tYs2wFdIhIVv3ZUZsHVO","34X5p5SURG3baakuuC7y2k","f11vuvExtP2bqtAkKwUGen","9fx3DWakRGYb/7wkJr+vTZ","66oB8lGqlBsaOGycP6bbVf@f9941","84cLcihGdNeKbe8zexzNPy@f9941","88kiIQmB5H949HmuBiH6bG@f9941","07LYjsHPtGtpo4Xg7680i6@6c48a","077uUy6eVAuZnt1J/ZFqj8@6c48a","171BwH9q5Jy6/0BFeSkb6r@6c48a","20g1ukYUVPvKWKBRznAKo+@6c48a","e8UdS53ylDOp3mrEFOfbKb","2a9EYeAqtHC6hAawpGjhPB@6c48a","39fMmKVvdDFaZU/Wj+8dt1@f9941","c7Btmx8N5ChK6kk6N7CMHB@f9941","4eBAm3TOhGdIN3eQQhL2z4@f9941","dblooaYXZDMpMLWxA8Txkd@f9941","a97nDcFINM+pOlGxtXV7g0@f9941","39fMmKVvdDFaZU/Wj+8dt1@6c48a","39gD4hZZZGJYAMZfAbIHYC@6c48a","171BwH9q5Jy6/0BFeSkb6r@f9941","39gD4hZZZGJYAMZfAbIHYC@f9941","4eBAm3TOhGdIN3eQQhL2z4@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","56WEMhYCBCjIt6jxQ2bOwd@6c48a","fdSWuec6RPmpnXb3hAPpiM@f9941","78qy2oMatCSof6/1gvdR5R@f9941","815NaNlXNHa4HmZJViq3oo","33RbgKQ11ISYBoCeUUGVHv","86tpqn+4RLRIRXE9v2tRrm","61JEMRvfxLho6zdgqJB+zd@6c48a","65YDJRyypPWKaEB5GtMZFf@6c48a","68wt//yuFA1I+LWpDhzY6A@6c48a","56WEMhYCBCjIt6jxQ2bOwd@f9941","aeIAc1qm5DdI7jixSzZWSd","feoZ8QsD9FH7EciE8JGMpn","1byBrBh45ANJ24DMYCacXX","5bfQQFu85AnrD7hyC51yvz","29Pf62MaNDu5asngmzTA45","76jc7Sqf5FzKhCZv0LWi0+","dex5i3xNBJhpbQxwUKgBcf","4ccRbxjopEg7ntFoqXXD8l","e9Lrtt6XxDhqV1TyALT4LO","b5NZRMe7NDnI3mXUgOruvP@f9941","89zVG/fLdIcIaDeIrAWmBJ","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@a804a","d0MqyYBeFAkIi762QNy1/B@b47c0","55+phfTLtG17VwCpM2bFeQ@b47c0","71GEFzvI1Ijqd90EeqRHYX@6c48a","74k+mBOm5IsoBHYb7IuvSD@6c48a","609xlc7CpF67qUiVX2DoHQ","78qy2oMatCSof6/1gvdR5R@6c48a","7dj5uJT9FMn6OrOOx83tfK@6c48a","84P1R7cFxMHoxr4wgTD4Vn@6c48a","84cLcihGdNeKbe8zexzNPy@6c48a","88kiIQmB5H949HmuBiH6bG@6c48a","77rlUftfpH1K/RwbvDZwXn","e2tSuyU+5ERo+E/KrC4+jb@f9941","68wt//yuFA1I+LWpDhzY6A@f9941","acDvw4R09CgrPQPXKjzSt0@f9941","8dlExriq5DrKB41muGXsTe@f9941","84P1R7cFxMHoxr4wgTD4Vn@f9941","8alTtAupxNEo2P97mR7FvF@6c48a","8dlExriq5DrKB41muGXsTe@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","a97nDcFINM+pOlGxtXV7g0@6c48a","1dvtlE/kJIqLKRXdVkzWn5@f9941","abZDzJnmROO7GV7L1x6BsE@6c48a","acDvw4R09CgrPQPXKjzSt0@6c48a","ac9+NqrJZO6aJpc7iP2NYJ@6c48a","b5NZRMe7NDnI3mXUgOruvP@6c48a","c7Btmx8N5ChK6kk6N7CMHB@6c48a","1brw/JvvpFnIvdrxpFCgMZ","d5+hfakm9ERbLfLFobVDcL@6c48a","dblooaYXZDMpMLWxA8Txkd@6c48a","abZDzJnmROO7GV7L1x6BsE@f9941","07LYjsHPtGtpo4Xg7680i6@f9941","e2tSuyU+5ERo+E/KrC4+jb@6c48a","d5+hfakm9ERbLfLFobVDcL@f9941","ac9+NqrJZO6aJpc7iP2NYJ@f9941","61JEMRvfxLho6zdgqJB+zd@f9941","74k+mBOm5IsoBHYb7IuvSD@f9941"],["node","root","asset","_spriteFrame","_textureSource","target","_normalSprite","targetInfo","data","source","_parent","_target","_hoverSprite","_pressedSprite","_disabledSprite","_font","_cameraComponent","scene","prefabRootNode","value","_targetTexture","_effectAsset","labelCoinRange","labelTitle","labelResultGetCoin","labelResultWiner","playerShowdown","bankerShowdown","lableCaption","frame","_mesh","_envmapHDR","_diffuseMapHDR","subRatio","subTableText","_customMaterial","label","sprite","chipContent","labelCoin","subGameState","subSimpleRoad","subDerailRoad","nodeArrow","buttonOpenRoad","item","prefabCurrntRoadItem","buttonReferLastBet","buttonClearBet","labelState","labelTime"],["cc.ImageAsset",["cc.Node",["_name","_layer","_id","_active","_objFlags","__editorExtras__","_components","_parent","_prefab","_children","_lpos","_lscale","_lrot","_euler"],-3,9,1,4,2,5,5,5,5],"cc.SpriteFrame","cc.Texture2D",["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","_cacheMode","_isBold","_overflow","_isSystemFontUsed","_horizontalAlign","_enableWrapText","node","__prefab","_color"],-7,1,4,5],["cc.Sprite",["_sizeMode","_type","_enabled","node","_spriteFrame","__prefab","_color","_customMaterial"],0,1,6,4,5,6],["cc.Node",["_name","_layer","_components","_prefab","_parent","_lpos","_children","_lrot","_euler","_lscale"],1,12,4,1,5,2,5,5,5],["cc.Node",["_name","_layer","_parent","_components","_children","_prefab","_lpos"],1,1,2,2,4,5],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.PrefabInfo",["fileId","nestedPrefabInstanceRoots","root","asset","targetOverrides"],2,2,1,1,9],["cc.Button",["_transition","_zoomScale","node","__prefab","_normalSprite","clickEvents","_normalColor","_target","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,4,6,9,5,1,6,6,6],["cc.Layout",["_layoutType","_spacingX","_resizeMode","_spacingY","_paddingLeft","_paddingTop","node","__prefab","_cellSize"],-3,1,4,5],["cc.Camera",["_visibility","_orthoHeight","_far","_clearFlags","_name","_iso","_projection","_priority","_enabled","node","_color","_targetTexture"],-6,1,5,6],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents","removedComponents"],1,9,9,9],["cc.UIOpacity",["_opacity","node","__prefab"],2,1,4],["cc.TargetOverrideInfo",["propertyPath","target","targetInfo","source","sourceInfo"],2,1,4,1,4],"cc.TextureCube",["cc.EffectAsset",["_name","shaders","techniques","combinations"],-1],["cc.PrefabInfo",["fileId","root","instance","asset","targetOverrides"],2,1,4,6,9],["cc.PrefabInstance",["fileId","propertyOverrides","prefabRootNode"],2,9,1],["cc.LabelOutline",["_width","node","__prefab","_color"],2,1,4,5],["c11309gdQRMirlQenmVpxvm",["type","node","__prefab","spriteCardResult","labelResult"],2,1,4,2,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Widget",["_alignFlags","_left","_right","_top","_bottom","node"],-2,1],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_near","_far","_shadowColor"],1,5],["cc.SkyboxInfo",["_useHDR","_envmapHDR","_diffuseMapHDR"],2,6,6],["cc.FogInfo",["_fogColor"],3,5],["cc.Mask",["_enabled","node","__prefab"],2,1,4],["cc.PolygonCollider2D",["_sensor","node","_points","__prefab"],2,1,12,4],["108a7FSLhtEwakZmqjVmWET",["updateTarget","contentNode","node","__prefab"],1,1,4],["cc.Material",["_props","_defines","_states"],0],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],"cc.RenderTexture",["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Prefab",["_name"],2],["cc.Node",["_name","_id","_parent","_children","_lpos"],1,1,12,5],["cc.CompPrefabInfo",["fileId"],2],["77f666+gthOMZIH/TEdK+7L",["node","__prefab","labelTitle","labelCoinRange"],3,1,4,1,1],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["cc.TargetInfo",["localID"],2],["28424S7hVtOwpUmP4NwZg3F",["node","__prefab"],3,1,4],["7bad31+lIVHXb1T0huoxdlc",["node","__prefab"],3,1,4],["cc.BlockInputEvents",["node","__prefab"],3,1,4],["11a634AOyZPRKbpbHpzm/co",["node","__prefab","buttonCoinType","uiTransformCoinType","spriteCoinType"],3,1,4,2,2,2],["3e350c/TOlAtaxlIpQ+QEfQ",["node","__prefab","bankerShowdown","playerShowdown","labelResultWiner","labelResultGetCoin"],3,1,4,1,1,1,1],["e764dzmf5xK9r4RjSm9eHTf",["node","__prefab","frame","lableCaption"],3,1,4,1,1],["cc.SceneAsset",["_name"],2],["906bc2faE1DOqu2MP1zQIXg",["node"],3,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.OctreeInfo",[],3],["15ca9Waxy9FPY+xcaPFNGfA",["node"],3,1],["02ccadWhrFMrru0B8V26hNI",["node"],3,1],["4baf0MtEdxKBYiOKXlRC+wG",["node"],3,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,2],["98592aSaN5HCbrZPBX4CcSG",["panelShowdownResult","panelTable","panelCardSequence","panelClientCoin","panelGameMessage","panelLimitBet","panelTextureTable","panelTimer","panel_UI","node"],-6,1],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh"],2,1,3,4,6],["cc.ModelLightmapSettings",[],3],["fa515qP4eJNWKqNL5TmiiN+",["node","__prefab","arraySubCoinStateItem"],3,1,4,2],["0ea30A4n7ZMwosdqxI3B/do",["node","__prefab","labelCoin"],3,1,4,1],["803f6qeN3hNAKI+y2PJxKuS",["node","__prefab"],3,1,4],["cc.TTFFont",["_name","_native"],1],["0d6acKPN3RJlIxKhqjypAvt",["node","__prefab"],3,1,4],["48a94ENyWdM+o7obShPA//S",["subBetEffect","node","__prefab","subTableText","subRatio"],2,1,4,1,1],["d8373OrQPdCVaM5pLHialKs",["node","__prefab","sprites"],3,1,4,2],["cc.RenderRoot2D",["node","__prefab"],3,1,4],["7e034oc1aJGwL36TtQx4Hdn",["node","__prefab","spriteText"],3,1,4,2],["84c09R2jUdNZa/MyyEx97KN",["node","__prefab"],3,1,4],["653bbdPZ3RDmKpDCzluqRM3",["node"],3,1],["8376eKdxAhMbLmgd6I/ZV1j",["node","__prefab","sprite","label"],3,1,4,1,1],["7ada3RdycVF6os0M4OQVbyS",["textureTable","node","__prefab"],2,1,4],["11f15lnWzZKJKb1oV3lFWs+",["node","__prefab","arrayButtonNode","chipContent"],3,1,4,2,1],["d8d641IYulPLa9e4qclAhl6",["node","__prefab","labelCoin"],3,1,4,1],["58689AoFQpIdZ1CKJgnZgR3",["node","__prefab"],3,1,4],["2cd5f1J+HBNd58/uslOhiDu",["node","__prefab","subDerailRoad","subSimpleRoad","subGameState"],3,1,4,1,1,1],["17f92DDALpHsL176UpBx1SN",["itemContent","__prefab"],2,4],["cc.ScrollView",["bounceDuration","brake","vertical","node","__prefab","_content"],0,1,4,1],["c8e12WRFB1BBo/lih+FzWve",["node","__prefab","updateTarget","contentNode"],3,1,4,1,1],["f5c90AA6tBEUoVKY9if/KWb",["node","__prefab","subRoad","subBigRoad"],3,1,4,1,1],["f9991ghg0BNZIOtk+d2a82N",["node","__prefab"],3,1,4],["125537lRHhD2L1NGhuXGmQT",["node","__prefab","buttonClearBet","buttonReferLastBet"],3,1,4,1,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9],["5da5dNboMpC7ZHw9reouMyQ",["node","__prefab","labelTime","labelState"],3,1,4,1,1]],[[40,0,1,2,2],[45,0,2],[37,0,2],[1,4,5,7,8,3],[18,0,1,2,3,2],[19,0,2,1,2],[39,0,1,2,3],[9,0,2,3,2],[8,0,1,2,1],[42,0,1,2,2],[8,0,1,2,3,1],[1,0,1,7,6,8,10,3],[41,0,1,2,3],[8,0,2,1],[1,0,1,7,6,8,3],[5,3,5,4,1],[5,0,3,5,4,2],[8,0,1,1],[35,0,2],[1,0,1,9,6,8,3],[6,0,1,4,2,3,5,3],[15,0,3,4,1,2,2],[15,0,3,1,2,2],[15,0,1,2,2],[72,0,1,1],[1,0,4,1,7,6,4],[4,0,1,2,6,9,10,12,6],[5,3,5,1],[5,1,0,3,4,3],[10,0,2,5,6,7,4,8,9,10,2],[62,0,1,2,3],[6,0,1,4,2,3,5,9,3],[1,0,1,7,6,8,10,11,3],[1,0,1,7,9,6,10,3],[6,0,1,4,6,2,3,5,3],[11,2,0,1,6,7,4],[4,0,1,2,3,10,11,5],[13,0,1,2,3],[1,0,1,7,9,6,8,3],[14,1,2,1],[5,0,3,5,2],[1,0,1,7,9,6,8,10,3],[4,0,1,2,10,11,4],[4,0,1,2,6,7,10,11,12,6],[10,2,3,1],[20,0,1,2,3,2],[28,0,1,2,2],[29,0,1,3,2,2],[66,0,1,2,1],[83,0,1,2,3,4,5,4],[7,0,1,2,4,3,5,6,3],[1,0,1,2,9,6,10,4],[1,0,2,7,6,3],[6,0,1,4,2,3,5,7,8,3],[6,0,1,4,2,3,3],[6,0,1,4,6,2,3,3],[4,0,1,2,3,5,10,11,12,6],[19,0,1,2],[5,0,3,5,6,4,2],[10,0,2,3,2],[20,0,1,2,2],[52,0,2],[22,0,1,1],[23,0,5,2],[54,0,1,2,3,2],[55,0,1,2,3,4,1],[56,1],[12,6,7,1,2,3,0,9,10,7],[1,4,5,8,3],[1,0,1,2,7,6,4],[1,0,1,7,9,6,3],[1,0,1,7,6,3],[1,0,1,9,6,8,10,3],[1,0,3,1,7,6,8,10,4],[7,0,2,3,6,2],[7,0,2,4,3,5,2],[8,0,1],[9,0,2,3,4,1,2],[18,0,1,2,4,3,2],[4,0,1,2,3,4,10,11,12,6],[4,0,1,5,10,11,4],[4,0,1,2,3,7,5,10,11,12,7],[5,1,0,3,5,6,4,3],[5,1,0,3,5,4,3],[48,0,1,1],[10,0,1,2,3,4,3],[24,1,2,1],[25,0,1,2,3],[26,1],[27,1],[68,0,1,3],[34,0,1,2,3],[17,0,1,2,4],[17,0,3,1,2,5],[1,0,1,6,8,10,3],[1,0,1,2,7,9,6,10,4],[1,0,1,9,6,10,3],[1,0,2,6,3],[1,0,2],[1,0,3,1,7,9,6,4],[1,0,7,2],[1,0,1,7,6,10,3],[1,0,3,1,7,6,4],[1,0,7,6,10,12,13,2],[1,0,3,7,6,10,12,13,3],[1,0,1,7,9,6,8,11,3],[1,0,9,6,8,2],[1,0,7,9,6,8,2],[1,0,1,7,6,8,11,3],[1,0,2,7,6,10,3],[1,0,9,6,8,10,2],[1,0,1,6,8,3],[1,0,1,7,9,6,8,10,11,3],[1,0,3,1,7,9,6,8,4],[1,0,3,1,7,9,6,8,10,4],[6,0,1,6,2,3,3],[6,0,1,6,2,3,5,3],[7,0,1,2,4,3,5,3],[7,0,1,2,3,6,3],[36,0,1,2,3,4,3],[38,0,1,2,3,1],[9,0,1,2],[9,0,4,1,2],[9,0,2],[4,0,1,2,3,6,4,10,11,12,7],[4,0,1,5,10,11,12,4],[4,0,1,2,5,10,11,12,5],[4,0,1,4,10,11,4],[4,0,1,2,3,4,10,11,6],[4,0,8,1,2,3,4,10,11,7],[4,0,8,1,2,3,6,10,11,7],[4,0,1,2,10,11,12,4],[13,0,1,3,2,3],[13,0,1,2,4,3],[43,0,1,2,2],[44,0,1,2,2],[14,1,1],[14,0,1,2,2],[46,0,1,1],[47,0,1,1],[5,0,3,6,4,2],[5,0,3,4,2],[5,3,6,4,1],[5,0,3,5,7,4,2],[5,2,3,5,4,2],[49,0,1,2,3,4,1],[11,2,0,1,3,6,8,5],[11,2,0,1,3,6,5],[11,0,4,5,1,3,6,7,6],[50,0,1,2,3,4,5,1],[21,1,2,3,4,1],[21,0,1,2,3,4,2],[51,0,1,2,3,1],[22,0,1],[23,0,1,2,3,4,5,6],[53,0,1],[24,0,1,2,3,4,2],[25,2,1],[26,0,1,2,2],[27,0,1],[57,0,1],[58,0,1],[59,0,1],[12,4,1,2,3,5,0,9,10,11,7],[12,4,8,1,2,3,5,0,9,10,11,8],[12,0,9,2],[28,1,1],[60,0,1,1],[61,0,1,2,3,4,5,6,7,8,9,10],[29,1,2,1],[30,0,1,3],[30,0,1,2,3,3],[63,0,1,2,3,4,2],[64,1],[65,0,1,2,1],[31,0,2,1,4],[31,0,1,3],[67,0,1,1],[69,0,1,1],[70,0,1,2,3,4,2],[71,0,1,2,1],[73,0,1,2,1],[74,0,1,1],[75,0,1],[76,0,1,2,3,1],[77,0,1,2,2],[78,0,1,2,3,1],[79,0,1,2,1],[80,0,1,1],[81,0,1,2,3,4,1],[82,0,1,2],[84,0,1,2,3,1],[85,0,1,2,3,1],[86,0,1,1],[87,0,1,2,3,1],[88,0,1],[89,0,1,2],[90,0,2],[91,0,1,2,3],[92,0,1,2],[32,0,2],[32,1,2,0,4],[93,0,1,2,3,1]],[[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["07LYjsHPtGtpo4Xg7680i6"]}],[3],0,[],[],[]],[[{"name":"icon_amoun","rect":{"x":1,"y":1,"width":25,"height":23},"offset":{"x":0,"y":-0.5},"originalSize":{"width":27,"height":24},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[21]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["077uUy6eVAuZnt1J/ZFqj8"]}],[3],0,[],[],[]],[[{"name":"lby_table0","rect":{"x":1,"y":0,"width":180,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":182,"height":182},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[22]],[[[91,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["171BwH9q5Jy6/0BFeSkb6r"]}],[3],0,[],[],[]],[[{"name":"bg_bopen","rect":{"x":0,"y":0,"width":278,"height":368},"offset":{"x":0,"y":0},"originalSize":{"width":278,"height":368},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[23]],[[[92,"builtin-standard",[{"hash":4038009253,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":222,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":210600745,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[18,"PanelLimitBet"],[19,"PanelLimitBet",33554432,[-6,-7],[[8,-2,[2,"14hnstWmJITrb+fj3XyYPG"],[5,0,0]],[120,-5,[2,"729pBlxj1AgIjcx1RsPL/Q"],-4,-3]],[7,"78FnrskSRPmJDtjOBKnSKo",-1,0]],[20,"LabelTitle",33554432,1,[[[8,-8,[2,"9elhqoi/RJY4ect5yimx0l"],[5,44,50.4]],-9],4,1],[7,"8aJnP/oWROSrKMPMiXQ7jc",1,0],[1,278.533,415.644,0]],[20,"LabelCoinRange",33554432,1,[[[8,-10,[2,"8c+P4qcq1Iv4DvA/4hHDVD"],[5,116.38,50.4]],-11],4,1],[7,"40DeV0a61LNqpsaVTkoD6k",1,0],[1,383.171,417.678,0]],[42,"限額",22,22,2,[2,"e1Q5zzgshCs4gASva+g2Pm"]],[42,"100-10,000",23,23,3,[2,"79IJFa8O5OSYMM3p03THI5"]]],0,[0,1,1,0,0,1,0,22,5,0,23,4,0,0,1,0,-1,2,0,-2,3,0,0,2,0,-2,4,0,0,3,0,-2,5,0,8,1,11],[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[3],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[2],0,[0],[4],[24]],[[[18,"PanelUI"],[68,0,null,[4,"1cGsAvu1ZBVZecqlfD+SZG",-6,[5,"ecwl+H+YBHAIcv7IOMmSi7",-5,[[6,"UIClientChipButton",["_name"],-1],[0,["_lpos"],-2,[1,0,0,0]],[0,["_lrot"],-3,[3,0,0,0,1]],[0,["_euler"],-4,[1,0,0,0]],[12,null,["buttonClearBet"],[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[12,false,["_enabled"],[1,["8dAqpCLRZE2avCmT2K9zbn"]]]]],1]],[115,"PanelUI",33554432,[-20,1,-21,-22],[[[8,-17,[2,"a086ATPC5OY6Mst1qSIvZq"],[5,0,0]],-18,[39,-19,[2,"6dUiz6ehNIWJyq79x83Crd"]]],4,1,4],[77,"f0aLVhM8VMSakv/beoxl3I",-16,0,[[21,["buttonCoinType","0"],1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],1,[1,["25HCPvYH1G5I5Bx7O0czUE"]]],[21,["buttonCoinType","1"],1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],1,[1,["a4kyx5JVFOIqgc597UJSsn"]]],[21,["buttonCoinType","2"],1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],1,[1,["91zynHtpxP+5RLgyPzKLC7"]]],[21,["buttonCoinType","3"],1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],1,[1,["8fLgpNQs5MB6POISZD81NR"]]],[21,["buttonCoinType","4"],1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],1,[1,["a6c+zLvepEe7D6Dh9mL9Uf"]]],[22,["uiClientBetButton"],-10,1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[22,["uiClientChipButton"],-11,1,[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[22,["uiClinetTableBetButton"],-13,-12,[1,["17RXaM4P9HZKWFYltOqkf2"]]],[22,["uiBetFunctionButton"],-15,-14,[1,["0arRrLW7FPAZ+Vrchn0LyH"]]]],[-7,1,-8,-9]]],[138,2,[2,"46KYvhA9ZE3qjr2v6DLRW2"]],[3,0,null,2,[4,"08EHpoiw9MMbzMb0cGOHBB",-27,[5,"29e4sfQjtPy5vOm54yyvNw",2,[[6,"UIClinetTableBetButton",["_name"],-23],[0,["_lpos"],-24,[1,0,0,0]],[0,["_lrot"],-25,[3,0,0,0,1]],[0,["_euler"],-26,[1,0,0,0]]]],0]],[1,["08EHpoiw9MMbzMb0cGOHBB"]],[1,["1cGsAvu1ZBVZecqlfD+SZG"]],[3,0,null,2,[4,"8fe3u7WjhHkIbsSZh4Gvyc",-32,[5,"75ivSr/D5FTqKEP8ZdgscS",2,[[6,"UIBetFunctionButton",["_name"],-28],[0,["_lpos"],-29,[1,0,0,0]],[0,["_lrot"],-30,[3,0,0,0,1]],[0,["_euler"],-31,[1,0,0,0]]]],2]],[1,["8fe3u7WjhHkIbsSZh4Gvyc"]],[1,["11ESLde4xL1bL911jpKNiy"]],[3,0,null,2,[4,"11ESLde4xL1bL911jpKNiy",-33,[5,"1bz0rYCrhCAYILjRytVVCi",2,[[6,"UITabelChipContent",["_name"],9],[0,["_lpos"],9,[1,0,0,0]],[0,["_lrot"],9,[3,0,0,0,1]],[0,["_euler"],9,[1,0,0,0]]]],3]]],0,[0,7,6,0,7,6,0,7,6,0,7,6,0,18,2,0,1,1,0,-1,4,0,-3,7,0,-4,10,0,9,3,0,9,3,0,5,4,0,9,3,0,5,7,0,9,3,0,1,2,0,0,2,0,-2,3,0,0,2,0,-1,4,0,-3,7,0,-4,10,0,7,5,0,7,5,0,7,5,0,7,5,0,1,4,0,7,8,0,7,8,0,7,8,0,7,8,0,1,7,0,1,10,0,8,2,1,10,2,33],[0,0,0,0],[2,2,2,2],[14,15,16,25]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["2a9EYeAqtHC6hAawpGjhPB"]}],[3],0,[],[],[]],[[{"name":"icon_r","rect":{"x":0,"y":0,"width":90,"height":90},"offset":{"x":0,"y":0},"originalSize":{"width":90,"height":90},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[26]],[[[18,"PanelSystemMessage"],[19,"PanelSystemMessage",33554432,[-5,-6],[[17,-2,[2,"1dHrZ48dpGeYOXliaQ2bv5"]],[39,-3,[2,"bb0o/l4D9OA4LwDcEXqk68"]],[139,-4,[2,"60sHxXdSlL8pJEhxNBuc/I"]]],[7,"1ciS7u5yxInLVmA8wGOQBN",-1,0]],[38,"Frame",33554432,1,[-8,-9,-10,-11,-12,-13],[[17,-7,[2,"7fTto0eZ5CoZ/aFWt1b/S4"]]],[7,"dcblmgKqRDL7FBMuu2WdEq",1,0]],[14,"SpriteBG",33554432,1,[[8,-14,[2,"11E9DAVZNIzL8j8N8SSjr6"],[5,1431,1080]],[82,1,0,-15,[2,"66z7zzhh9NPJgpMj1zI3a6"],[4,1578966301],0],[84,-16,[2,"aaUCqDLPFEZpLNPhcB7Zz1"]]],[7,"a3gKQOY6tNHpOqToBB8aJR",1,0]],[11,"ButtonCancel",33554432,2,[[8,-17,[2,"612qXs7aNE06N6EScAA9gQ"],[5,112.374,50]],[83,1,0,-18,[2,"13tBGmcTFB8rOC4fo2rctE"],2],[85,3,0.9,-19,[2,"fay3CzEQ5OjalKPOOAZmJR"],3]],[7,"31YTdpSSREQoqU/WFdddXv",1,0],[1,-91.18700000000001,-128.42200000000003,0]],[11,"ButtonConfirm",33554432,2,[[8,-20,[2,"9eUUgr6hFERKnUbkyXAe6O"],[5,112.374,50]],[83,1,0,-21,[2,"193vbxLRZLJrpSFGnf63FD"],4],[85,3,0.9,-22,[2,"b5dx7Au0JIB7uTHxOrwO7Q"],5]],[7,"29Du2Bq7VEg7Q7Pi1chnsw",1,0],[1,0,-128.42200000000003,0]],[32,"LabelCancel",33554432,2,[[8,-23,[2,"22ofNoEE5MMZlQWvxCcJ1o"],[5,102.5,81]],[79,"取消",50,50,80,2,-24,[2,"b4wpkuxTBAyaHCG2pQg/mF"],[4,4278190080]],[60,0.5,-25,[2,"04/JazHAFCl7K0Ybnd9NLK"]]],[7,"124uU1UeRCDbb2IMmzOtXD",1,0],[1,-81.238,-133.298,0],[1,0.5,0.5,0.5]],[32,"LabelConfirm",33554432,2,[[8,-26,[2,"aeX9YbM0lOX5Z2WD7YxrFE"],[5,102.5,81]],[79,"確定",50,50,80,2,-27,[2,"1fWNKoR9RDnb2K8Cfa0ZfF"],[4,4278190080]],[60,0.5,-28,[2,"0azFHCTSdP1JYbLt5vSG8e"]]],[7,"19xgnm35xGMoGParO5h0vY",1,0],[1,138.973,-133.298,0],[1,0.5,0.5,0.5]],[32,"LabelCaption",33554432,2,[[8,-29,[2,"ff6tT9Ht9HWrLLVYlDBLEQ"],[5,877.6279999999999,401]],[124,"MEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEME",80,80,80,3,2,-30,[2,"7cR4dGSwdDFrzy2qSZd+0t"],[4,4278190080]],[60,0.5,-31,[2,"b7aGigBQlPyYalXebZbeI0"]]],[7,"ddq02bTdRCu6ywhazgbOeB",1,0],[1,0,50,0],[1,0.5,0.5,0.5]],[14,"SpriteBG",33554432,2,[[8,-32,[2,"f3vidKj1FBQ6xW6vl5TOxc"],[5,500,400]],[82,1,0,-33,[2,"34VvwrPV1L7ZnJLTk7yktX"],[4,4294920868],1]],[7,"fbTGdQJrFHlrBVey6F9CIu",1,0]]],0,[0,1,1,0,0,1,0,0,1,0,0,1,0,-1,3,0,-2,2,0,0,2,0,-1,9,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-6,8,0,0,3,0,0,3,0,0,3,0,0,4,0,0,4,0,0,4,0,0,5,0,0,5,0,0,5,0,0,6,0,0,6,0,0,6,0,0,7,0,0,7,0,0,7,0,0,8,0,0,8,0,0,8,0,0,9,0,0,9,0,8,1,33],[0,0,0,0,0,0],[3,3,3,6,3,6],[1,8,1,1,1,1]],[[[18,"UIClientChipButton"],[19,"UIClientChipButton",33554432,[-20],[[8,-2,[2,"90lkVwhZFLzqXfpvXcDbc0"],[5,0,0]],[145,-18,[2,"a3V6vEnvFFw7zUyzuX1g1n"],[-13,-14,-15,-16,-17],[-8,-9,-10,-11,-12],[-3,-4,-5,-6,-7]],[39,-19,[2,"9dQYUi5lFKf7UXvaN3N/ek"]]],[7,"1cGsAvu1ZBVZecqlfD+SZG",-1,0]],[41,"CoinType",33554432,1,[-23,-24,-25,-26,-27],[[8,-21,[2,"0dCO79lUdK84pLaAHhBDvq"],[5,980,100]],[35,1,1,20,-22,[2,"55Fzz+yQlLJqenSGgw9wPM"]]],[7,"c629+QwLlBSqKuiMo9kg3z",1,0],[1,-9,-163.338,0]],[50,"0",33554432,2,[-31],[-28,-29,-30],[7,"c3PH7pTX1H6p1K6NpSaB1W",1,0],[1,-400,0,0]],[50,"1",33554432,2,[-35],[-32,-33,-34],[7,"78FqGz5k1BKZXxaPgNPO7T",1,0],[1,-200,0,0]],[117,"2",33554432,2,[-39],[-36,-37,-38],[7,"9fiLd0MlFPzITN6hSXY5LQ",1,0]],[50,"3",33554432,2,[-43],[-40,-41,-42],[7,"b8qyeMalFBOaaihCk+3sPN",1,0],[1,200,0,0]],[50,"4",33554432,2,[-47],[-44,-45,-46],[7,"51jQL+2E5Mpb7ahwvkEbnU",1,0],[1,400,0,0]],[14,"chip",33554432,3,[[8,-48,[2,"e7S05c+1xB+66OLvkgPo3d"],[5,137,137]],[15,-49,[2,"d2HkZqbKpDc6r4KYKakgFi"],0]],[7,"835rYbOjpG+K3WAQ9bhWUb",1,0]],[14,"chip",33554432,4,[[8,-50,[2,"5foGa+xglGmpTe1dR/OIP1"],[5,137,137]],[15,-51,[2,"baY9KEy6FDEZVWkIfRt8H3"],1]],[7,"03CJaiLtBPOppSFUrVUo+I",1,0]],[14,"chip",33554432,5,[[8,-52,[2,"e5pUyv7QRLCp/XYDK62awi"],[5,137,137]],[15,-53,[2,"20/DEkX65KdblY9LGjld5R"],2]],[7,"8bmx37sKdFyLpzJW9xcULJ",1,0]],[14,"chip",33554432,6,[[8,-54,[2,"63Efgm8oxA7oMMrBCyvEUA"],[5,137,137]],[15,-55,[2,"e1rwRtiVZK84tEN7QJxReA"],3]],[7,"f7lMpt01tBvZSRXrsLiekX",1,0]],[14,"chip",33554432,7,[[8,-56,[2,"b3UXfuXtZLNKNQ19W/Vxn6"],[5,137,137]],[15,-57,[2,"0cxGmN1gRM86oYWV1xe5UY"],4]],[7,"3eaGXoq0FKUZItACWlfTzJ",1,0]],[8,3,[2,"5aw7TEqaBI1r443DAQPWD+"],[5,180,182]],[27,3,[2,"8dAqpCLRZE2avCmT2K9zbn"]],[44,3,[2,"25HCPvYH1G5I5Bx7O0czUE"]],[8,4,[2,"98zANNXRpAUq1G2rvSOXnM"],[5,180,182]],[27,4,[2,"8fOIwOyJhAPKuKYG45E1NP"]],[44,4,[2,"a4kyx5JVFOIqgc597UJSsn"]],[8,5,[2,"ac9Xk9w4ZL3Y/xHQpcTw95"],[5,180,182]],[27,5,[2,"d8S5AHKAVKEIyWqo0HFlts"]],[44,5,[2,"91zynHtpxP+5RLgyPzKLC7"]],[8,6,[2,"86CQF/kqhLZoGb9sXoEjBq"],[5,180,182]],[27,6,[2,"d145FA2rtHo6Yi9rAWM9FK"]],[44,6,[2,"8fLgpNQs5MB6POISZD81NR"]],[8,7,[2,"1cEP78evVJ4a7vAzUnj7OR"],[5,180,182]],[27,7,[2,"9cs8JfgnNEL7HbLwPTgTs9"]],[44,7,[2,"a6c+zLvepEe7D6Dh9mL9Uf"]]],0,[0,1,1,0,0,1,0,-1,14,0,-2,17,0,-3,20,0,-4,23,0,-5,26,0,-1,13,0,-2,16,0,-3,19,0,-4,22,0,-5,25,0,-1,15,0,-2,18,0,-3,21,0,-4,24,0,-5,27,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,-1,3,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-1,13,0,-2,14,0,-3,15,0,-1,8,0,-1,16,0,-2,17,0,-3,18,0,-1,9,0,-1,19,0,-2,20,0,-3,21,0,-1,10,0,-1,22,0,-2,23,0,-3,24,0,-1,11,0,-1,25,0,-2,26,0,-3,27,0,-1,12,0,0,8,0,0,8,0,0,9,0,0,9,0,0,10,0,0,10,0,0,11,0,0,11,0,0,12,0,0,12,0,8,1,57],[0,0,0,0,0,14,15,17,18,20,21,23,24,26,27],[3,3,3,3,3,3,6,3,6,3,6,3,6,3,6],[27,28,29,30,31,6,6,6,6,6,6,6,6,6,6]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["39fMmKVvdDFaZU/Wj+8dt1"]}],[3],0,[],[],[]],[[{"name":"lby_table1","rect":{"x":0,"y":0,"width":137,"height":137},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":137},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[32]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["39gD4hZZZGJYAMZfAbIHYC"]}],[3],0,[],[],[]],[[{"name":"bg_popen","rect":{"x":0,"y":0,"width":278,"height":368},"offset":{"x":0,"y":0},"originalSize":{"width":278,"height":368},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[33]],[[[18,"PanelShowdownResult"],[19,"PanelShowdownResult",33554432,[-9,-10,-11,-12,-13],[[17,-2,[2,"8eYuxdyjFLTakG11VZlMYz"]],[39,-3,[2,"d7HsVf1tZIFZ75rRWVlRAs"]],[149,-8,[2,"f42IepgpVLP6vztzjiSU9k"],-7,-6,-5,-4]],[7,"396TnbSahGTYkhYszl0MFW",-1,0]],[34,"SubShowdownBanker",33554432,1,[-16,-17,-18,-19,-20],[[[17,-14,[2,"87DTepIZVPtIFfytZtA7EZ"]],-15],4,1],[7,"e1qP1OMTpCq6oN2scg5s0H",1,0],[1,209.978,130.988,0]],[34,"SubShowdownPlayer",33554432,1,[-23,-24,-25,-26,-27],[[[17,-21,[2,"64DQpRRiBB8rGB1HLMbDO/"]],-22],4,1],[7,"f88qDlo/FKaZromswZKUz6",1,0],[1,-209.978,130.98800000000006,0]],[11,"SpriteBG",33554432,1,[[8,-28,[2,"58KgUik6lC+Z11NjXyz5Xy"],[5,1431,784]],[58,0,-29,[2,"3aJkKKuOFCF6q1NKuynFtc"],[4,3607101440],0]],[7,"92PZQZKUtNiJwzaNt/b+g2",1,0],[1,0,149,0]],[14,"SpriteBG",33554432,2,[[8,-30,[2,"91/H6FD6dDOKCeuVLjHyMc"],[5,278,368]],[15,-31,[2,"73vQgJtJRHs7cXO8mKjUi1"],1]],[7,"d47gdMMHpLBKWBroPLjywz",1,0]],[53,"SpriteCardResult0",33554432,2,[[[8,-32,[2,"54ou/44lxJE5MP+p8/iDOE"],[5,106,144]],-33],4,1],[7,"98tFiCRCZKBa11ussj23hq",1,0],[1,-50,17,0],[3,0,0,-1.2246467991473532e-16,-1],[1,0,0,-360]],[20,"SpriteCardResult1",33554432,2,[[[8,-34,[2,"50NREo58ZCYbDgReQuCjPN"],[5,106,144]],-35],4,1],[7,"156wYPOZdCtZBox0BBI/85",1,0],[1,50,17,0]],[53,"SpriteRepairCardResult",33554432,2,[[[8,-36,[2,"0aoqnRJplJzqxbggUZm01/"],[5,106,144]],-37],4,1],[7,"02RBqkhAFPD68uPztKrrsz",1,0],[1,0,-97.875,0],[3,0,0,-0.7071067811865475,0.7071067811865476],[1,0,0,-90]],[20,"LabelResult",33554432,2,[[[8,-38,[2,"85Qrigy7pJXrNhfXGjG+c1"],[5,75.57,50.4]],-39],4,1],[7,"b13QJWNVZPR5NY81FTxGf+",1,0],[1,0,133.563,0]],[14,"SpriteBG",33554432,3,[[8,-40,[2,"a1zOv0gvxBZ7W0ZLbDQSsT"],[5,278,368]],[15,-41,[2,"50nI1jk3hODaaBbKNX8Mau"],2]],[7,"8dlWx6sl9Jz5iDA1TfABxZ",1,0]],[20,"SpriteCardResult0",33554432,3,[[[8,-42,[2,"60tmHJB31MN6JTOgGCMoJU"],[5,106,144]],-43],4,1],[7,"51phU3XhlECYhOtxfY9ryD",1,0],[1,-50,17,0]],[20,"SpriteCardResult1",33554432,3,[[[8,-44,[2,"aeVlUiC2dC5pf4qGfZfUTc"],[5,106,144]],-45],4,1],[7,"b84E8hqHNB6oYmizrWfQ43",1,0],[1,50,17,0]],[53,"SpriteRepairCardResult",33554432,3,[[[8,-46,[2,"f0N39yuG9AeojDEuphVmwA"],[5,106,144]],-47],4,1],[7,"ba66xj9RxE2p0IcYh/l2Y0",1,0],[1,0,-97.875,0],[3,0,0,-0.7071067811865475,0.7071067811865476],[1,0,0,-90]],[20,"LabelResult",33554432,3,[[[8,-48,[2,"65QAMnmJ1O45hcYgYE1zQn"],[5,75.57,50.4]],-49],4,1],[7,"f9SykvaHBOq7/+37DsMc9B",1,0],[1,0,133.563,0]],[20,"LabelResultWiner",33554432,1,[[[8,-50,[2,"368PPWecBMfLAny+ybVeGl"],[5,80,50.4]],-51],4,1],[7,"83T9Bm2IdOg7DBL7LsjcY1",1,0],[1,0,162.4860000000001,0]],[20,"LabelResultGetCoin",33554432,1,[[[8,-52,[2,"5c6bweOQBFoI4CI9ODMSe9"],[5,60.06,50.4]],-53],4,1],[7,"26sjQRYTJIMoamK54dLsu5",1,0],[1,0,114.03000000000009,0]],[27,6,[2,"94m6W1nnBAKbgrTBaVP30M"]],[27,7,[2,"c7MN+F7HBATomvn2VeUdZS"]],[27,8,[2,"0b164KXfxLl6WlZHC3c5Rz"]],[80,"莊:7",40,true,9,[2,"f6jmNaMtpPF70d+04Rl1Mr"]],[150,2,[2,"11emCOMKpEAYzV6w4Ku4ET"],[17,18,19],20],[27,11,[2,"c8OLXOOX9HxaEmPdaeM1Oa"]],[27,12,[2,"64GgcJFPhLmp6dlUrt643U"]],[27,13,[2,"39L8jVd1xGhb6QxLuDGp19"]],[80,"莊:7",40,true,14,[2,"41fna+W79PW40guNPtdGf/"]],[151,1,3,[2,"caXi7cS2NBZpQPou4o+vly"],[22,23,24],25],[125,"閒贏",40,true,15,[2,"efzvphERFNQJuDJGsqh1fi"],[4,4294942760]],[126,"1200",27,27,true,16,[2,"6d2VemdJtAz44fHXxxIav2"],[4,4294942760]]],0,[0,1,1,0,0,1,0,0,1,0,24,28,0,25,27,0,26,26,0,27,21,0,0,1,0,-1,4,0,-2,2,0,-3,3,0,-4,15,0,-5,16,0,0,2,0,-2,21,0,-1,5,0,-2,6,0,-3,7,0,-4,8,0,-5,9,0,0,3,0,-2,26,0,-1,10,0,-2,11,0,-3,12,0,-4,13,0,-5,14,0,0,4,0,0,4,0,0,5,0,0,5,0,0,6,0,-2,17,0,0,7,0,-2,18,0,0,8,0,-2,19,0,0,9,0,-2,20,0,0,10,0,0,10,0,0,11,0,-2,22,0,0,12,0,-2,23,0,0,13,0,-2,24,0,0,14,0,-2,25,0,0,15,0,-2,27,0,0,16,0,-2,28,0,8,1,53],[0,0,0,17,18,19,22,23,24],[3,3,3,3,3,3,3,3,3],[8,34,35,7,7,7,7,7,7]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["4eBAm3TOhGdIN3eQQhL2z4"]}],[3],0,[],[],[]],[[{"name":"lby_table3","rect":{"x":0,"y":0,"width":137,"height":137},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":137},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[36]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[3],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[2],0,[0],[4],[37]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@e9a6d","back":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@40c10","left":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@8fd34","right":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@74afd","top":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@bb97f","bottom":"55fa985f-4cbb-46d7-b570-0a93366c5790@b47c0@7d38f"}]}],[16],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,1","mipmaps":["56WEMhYCBCjIt6jxQ2bOwd"]}],[3],0,[],[],[]],[[{"name":"bg_background","rect":{"x":0,"y":0,"width":1437,"height":789},"offset":{"x":0,"y":0},"originalSize":{"width":1437,"height":789},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[38]],[[[18,"RoadItem"],[94,"RoadItem",33554432,[[8,-2,[2,"32YFcwkmBG2I8mEsfWxHXb"],[5,40,40]],[16,0,-3,[2,"e6k0G24A9NV4bwYzaXSND+"],0]],[7,"d1LLgj3plJr7BgjvhEM8s0",-1,0],[1,23.75,-23.54,0]]],0,[0,1,1,0,0,1,0,0,1,0,8,1,3],[0],[3],[39]],[[[18,"PanelGameMessage"],[19,"PanelGameMessage",33554432,[-6],[[8,-2,[2,"0ctrE8/yFC05EFgP6TCY7r"],[5,0,0]],[152,-5,[2,"0dhDkQcsdDM5n8irksdv45"],-4,-3]],[7,"9bYa7kXVVETJ/fYwBpoGRl",-1,0]],[38,"Frame",33554432,1,[-8,-9],[[17,-7,[2,"7eOaAa62xDOpzGprgTLZQ6"]]],[7,"3fN8NWhcdDhYoCUHcITpOV",1,0]],[11,"SpriteBG",33554432,2,[[8,-10,[2,"3d32H7Y5NObbuuh8235Piy"],[5,391,47]],[15,-11,[2,"68RLiAYexNEI1EwnZ5Wb3n"],0]],[7,"7e7tDGT4lORJzENiUjz/qb",1,0],[1,0,427.41599999999994,0]],[20,"LableCaption",33554432,2,[[[8,-12,[2,"26kYFUMaVILI1yJi4GBSiF"],[5,227.5,50.4]],-13],4,1],[7,"2aEllayypJcqlR9sg9in2K",1,0],[1,0,427.41599999999994,0]],[42,"無法下注，如需下注請...",21,21,4,[2,"4d5NJS2tBLh7OalLI9RKbM"]]],0,[0,1,1,0,0,1,0,28,5,0,29,2,0,0,1,0,-1,2,0,0,2,0,-1,3,0,-2,4,0,0,3,0,0,3,0,0,4,0,-2,5,0,8,1,13],[0],[3],[40]],[[[61,"Loading"],[51,"CanvasNoClear",33554432,"1eYl8M+YRAyYvN+Lnj5FVz",[-5,-6,-7],[[13,-1,[5,1431,1080]],[153,-2],[63,45,-3],[155,-4]],[1,715.5,540,0]],[64,"Loading",[-11,-12,-13,1],[121,"602c3d25-484a-4071-ae9b-2b9ed340bc8b",[-8,-9,-10]],[65,[86,[2,0,0,0,0.520833125],[2,0,0,0,0]],[87,1,30,[4,4283190348]],[88],[89],[66]]],[95,"Canvas",33554432,"9aupFmx2BKQ7oxbW+rGmvu",2,[-18],[[13,-14,[5,1431,1080]],[62,-16,-15],[63,45,-17]],[1,715.5,540,0]],[1,["e6rSOiqj9LB7cxFfAzI2oi"]],[1,["00SMMrGs9JqrE3ebXm06qN"]],[1,["1ciS7u5yxInLVmA8wGOQBN"]],[69,"GameWebSocekt",33554432,"abHiUG9p9KMLzxXNXPNdyi",2,[[160,-19],[161,-20]]],[3,0,{},1,[4,"00SMMrGs9JqrE3ebXm06qN",-21,[57,"58WGtQf/JJiJ55dwsGJAA2",[[6,"PanelLoading",["_name"],5],[0,["_lpos"],5,[1,0,0,0]],[0,["_lrot"],5,[3,0,0,0,1]],[0,["_euler"],5,[1,0,0,0]]]],0]],[3,0,{},1,[4,"1ciS7u5yxInLVmA8wGOQBN",-22,[57,"f1LwLTUHdAD7GoKckjAfuN",[[6,"PanelSystemMessage",["_name"],6],[0,["_lpos"],6,[1,0,0,0]],[0,["_lrot"],6,[3,0,0,0,1]],[0,["_euler"],6,[1,0,0,0]]]],1]],[3,0,{},1,[4,"e6rSOiqj9LB7cxFfAzI2oi",-23,[57,"53EqfUSs5HGJjvVS0skuEG",[[6,"PanelVersion",["_name"],4],[0,["_lpos"],4,[1,0,0,0]],[0,["_lrot"],4,[3,0,0,0,1]],[0,["_euler"],4,[1,0,0,0]],[6,true,["_active"],4]]],2]],[69,"MainLoading",33554432,"67WF8zlT5AcYc4fUwFvTVE",2,[[162,-24]]],[74,"Camera",3,[-25],[1,0,0,1000]],[67,0,1073741824,540,2000,6,33554432,12,[4,4278190080]]],0,[0,0,1,0,0,1,0,0,1,0,0,1,0,-1,8,0,-2,9,0,-3,10,0,-1,8,0,-2,9,0,-3,10,0,-1,11,0,-2,7,0,-3,3,0,0,3,0,16,13,0,0,3,0,0,3,0,-1,12,0,0,7,0,0,7,0,1,8,0,1,9,0,1,10,0,0,11,0,-1,13,0,17,2,1,10,2,25],[0,0,0],[2,2,2],[41,42,43]],[[[93,"builtin-sprite",[{}],[{"hash":1770338543,"name":"builtin-sprite|sprite-vs:vert|sprite-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\n#if SAMPLE_FROM_RT\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\n  layout(location = 1) in vec2 uv0;\n  layout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":["USE_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":48,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":1}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"CC_USE_EMBEDDED_ALPHA","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"IS_GRAY","type":"boolean","defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"builtin-sprite|sprite-vs:vert|sprite-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["61JEMRvfxLho6zdgqJB+zd"]}],[3],0,[],[],[]],[[{"name":"bg_cphroad1_2","rect":{"x":0,"y":0,"width":775,"height":49},"offset":{"x":0,"y":0},"originalSize":{"width":775,"height":49},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[44]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["65YDJRyypPWKaEB5GtMZFf"]}],[3],0,[],[],[]],[[{"name":"icon_moneyend","rect":{"x":0,"y":0,"width":130,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":130,"height":36},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[45]],[[{"base":"2,2,0,0,0,1","w":1431,"h":1080,"n":""}],[33],0,[],[],[]],[[{"name":"","rect":{"x":0,"y":0,"width":1431,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1431,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[13]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["68wt//yuFA1I+LWpDhzY6A"]}],[3],0,[],[],[]],[[{"name":"bg_Sline3","rect":{"x":0,"y":0,"width":424,"height":317},"offset":{"x":0,"y":0},"originalSize":{"width":424,"height":317},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[46]],[[[61,"GameRoom"],[51,"Canvas",33554432,"202qdfRp1BcpZLP0nCR6bZ",[-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19],[[13,-1,[5,1431,1080]],[62,-3,-2],[154,18,360,360,640,640,-4],[166,-5]],[1,715.5,540,0]],[68,0,null,[4,"1cGsAvu1ZBVZecqlfD+SZG",-25,[5,"ecwl+H+YBHAIcv7IOMmSi7",-24,[[6,"UIClientChipButton",["_name"],-20],[0,["_lpos"],-21,[1,0,0,0]],[0,["_lrot"],-22,[3,0,0,0,1]],[0,["_euler"],-23,[1,0,0,0]],[12,null,["buttonClearBet"],[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[12,false,["_enabled"],[1,["8dAqpCLRZE2avCmT2K9zbn"]]]]],6]],[3,0,null,1,[78,"f0aLVhM8VMSakv/beoxl3I",-30,[37,"fb+swz/DVGW7num6noSPMB",null,[[12,"PanelUI",["_name"],[1,["f0aLVhM8VMSakv/beoxl3I"]]],[9,["_lpos"],[1,["f0aLVhM8VMSakv/beoxl3I"]],[1,0,0,0]],[9,["_lrot"],[1,["f0aLVhM8VMSakv/beoxl3I"]],[3,0,0,0,1]],[9,["_euler"],[1,["f0aLVhM8VMSakv/beoxl3I"]],[1,0,0,0]],[9,["_lscale"],[1,["ecwl+H+YBHAIcv7IOMmSi7","78FqGz5k1BKZXxaPgNPO7T"]],[1,1.2,1.2,1.2]],[12,false,["_enabled"],[1,["29e4sfQjtPy5vOm54yyvNw","36ME0WwoNP9JAFRVBpg4vm"]]],[0,["_lpos"],-28,[1,0,0,0]],[0,["_lscale"],-29,[1,1,1,1]]]],[[21,["buttonCoinType","0"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],2,[1,["25HCPvYH1G5I5Bx7O0czUE"]]],[21,["buttonCoinType","1"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],2,[1,["a4kyx5JVFOIqgc597UJSsn"]]],[21,["buttonCoinType","2"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],2,[1,["91zynHtpxP+5RLgyPzKLC7"]]],[21,["buttonCoinType","3"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],2,[1,["8fLgpNQs5MB6POISZD81NR"]]],[21,["buttonCoinType","4"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]],2,[1,["a6c+zLvepEe7D6Dh9mL9Uf"]]],[23,["uiClientBetButton"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[23,["uiClientChipButton"],2,[1,["a3V6vEnvFFw7zUyzuX1g1n"]]],[23,["uiClinetTableBetButton"],-26,[1,["17RXaM4P9HZKWFYltOqkf2"]]],[23,["uiBetFunctionButton"],-27,[1,["0arRrLW7FPAZ+Vrchn0LyH"]]]],5]],[3,0,null,1,[4,"396TnbSahGTYkhYszl0MFW",-31,[37,"12cI4Z9ktM3a6gdcKL0PDw",null,[[12,"PanelShowdownResult",["_name"],[1,["396TnbSahGTYkhYszl0MFW"]]],[9,["_lpos"],[1,["396TnbSahGTYkhYszl0MFW"]],[1,0,0,0]],[9,["_lrot"],[1,["396TnbSahGTYkhYszl0MFW"]],[3,0,0,0,1]],[9,["_euler"],[1,["396TnbSahGTYkhYszl0MFW"]],[1,0,0,0]],[12,255,["_opacity"],[1,["d7HsVf1tZIFZ75rRWVlRAs"]]],[9,["_lrot"],[1,["98tFiCRCZKBa11ussj23hq"]],[3,0,0,0,1]],[9,["_euler"],[1,["98tFiCRCZKBa11ussj23hq"]],[1,0,0,0]],[9,["_lscale"],[1,["396TnbSahGTYkhYszl0MFW"]],[1,1,1,1]],[9,["_lpos"],[1,["92PZQZKUtNiJwzaNt/b+g2"]],[1,0,122.4945,0]],[9,["_contentSize"],[1,["58KgUik6lC+Z11NjXyz5Xy"]],[5,1431,835]]]],11]],[3,0,null,1,[78,"4aEKBj3cVCArIMFwhj85in",-48,[132,"40oY/VxThDAZtRKrPhhnSw",null,[[167,[1,["507iPN3ZFDsa0aWJi4aqTb"]],[-47]]],[[12,"PanelCardSequence_Phone",["_name"],[1,["4aEKBj3cVCArIMFwhj85in"]]],[9,["_lpos"],[1,["4aEKBj3cVCArIMFwhj85in"]],[1,0,0,0]],[9,["_lrot"],[1,["4aEKBj3cVCArIMFwhj85in"]],[3,0,0,0,1]],[9,["_euler"],[1,["4aEKBj3cVCArIMFwhj85in"]],[1,0,0,0]],[12,true,["_active"],[1,["4aEKBj3cVCArIMFwhj85in"]]],[12,true,["_active"],[1,["9aTQdvpbZLe7aCegNxsEsv"]]],[12,true,["_active"],[1,["e9mpluQhZHQL7+pJwNHrIU"]]],[134,["item"],-44,13],[135,["subBigRoad"],-46,-45]]],[[23,["labelContent","0"],-32,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["labelContent","1"],-33,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["labelContent","2"],-34,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["labelContent","3"],-35,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["labelContent","4"],-36,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["labelContent","5"],-37,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[23,["itemContent","0"],-38,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[23,["itemContent","1"],-39,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[23,["itemContent","2"],-40,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[23,["itemContent","3"],-41,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[23,["itemContent","4"],-42,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[23,["itemContent","5"],-43,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]]],12]],[96,"Layout",33554432,[-51,-52,-53,-54,-55,-56,-57,-58],[[13,-49,[5,306,126]],[146,2,3,3,3,-50,[5,100,40]]],[1,-557.31,471.852,0]],[97,"MainGame","d3vrnD5sBNp7Op/ujgAiOm",[[168,null,null,null,null,null,null,null,null,null,-59]]],[98,"New Node"],[33,"Button",33554432,6,[-64],[[13,-60,[5,100,40]],[28,1,0,-61,21],[29,2,-63,[[30,"98592aSaN5HCbrZPBX4CcSG","backLobby",7]],[4,4292269782],-62,22,23,24,25]],[1,-103,43,0]],[33,"Button-003",33554432,6,[-69],[[13,-65,[5,100,40]],[28,1,0,-66,26],[29,2,-68,[[30,"98592aSaN5HCbrZPBX4CcSG","onOwnerBet",7]],[4,4292269782],-67,27,28,29,30]],[1,0,43,0]],[33,"Button-004",33554432,6,[-74],[[13,-70,[5,100,40]],[28,1,0,-71,31],[29,2,-73,[[30,"98592aSaN5HCbrZPBX4CcSG","onBetClear",7]],[4,4292269782],-72,32,33,34,35]],[1,103,43,0]],[33,"Button-005",33554432,6,[-79],[[13,-75,[5,100,40]],[28,1,0,-76,36],[29,2,-78,[[30,"98592aSaN5HCbrZPBX4CcSG","onReferLastBet",7]],[4,4292269782],-77,37,38,39,40]],[1,-103,0,0]],[70,"Button-006",33554432,6,[-84],[[13,-80,[5,100,40]],[28,1,0,-81,41],[29,2,-83,[[30,"98592aSaN5HCbrZPBX4CcSG","onBetCheck",7]],[4,4292269782],-82,42,43,44,45]]],[33,"Button-007",33554432,6,[-89],[[13,-85,[5,100,40]],[28,1,0,-86,46],[29,2,-88,[[30,"98592aSaN5HCbrZPBX4CcSG","onSquintEnd",7]],[4,4292269782],-87,47,48,49,50]],[1,103,0,0]],[33,"Button-008",33554432,6,[-94],[[13,-90,[5,100,40]],[28,1,0,-91,51],[29,2,-93,[[30,"98592aSaN5HCbrZPBX4CcSG","onSquintProcess",7]],[4,4292269782],-92,52,53,54,55]],[1,-103,-43,0]],[33,"Button-009",33554432,6,[-99],[[13,-95,[5,100,40]],[28,1,0,-96,56],[29,2,-98,[[30,"98592aSaN5HCbrZPBX4CcSG","onRefreshRoomState",7]],[4,4292269782],-97,57,58,59,60]],[1,0,-43,0]],[64,"GameRoom",[7,1,-109,-110],[122,"6d75f75e-afa0-42f6-b7ee-162d8198800d",[[21,["spriteCardResult","0"],4,[1,["11emCOMKpEAYzV6w4Ku4ET"]],4,[1,["94m6W1nnBAKbgrTBaVP30M"]]],[21,["spriteCardResult","1"],4,[1,["11emCOMKpEAYzV6w4Ku4ET"]],4,[1,["c7MN+F7HBATomvn2VeUdZS"]]],[21,["spriteOutCardResult"],4,[1,["11emCOMKpEAYzV6w4Ku4ET"]],4,[1,["0b164KXfxLl6WlZHC3c5Rz"]]],[21,["labelResult"],4,[1,["11emCOMKpEAYzV6w4Ku4ET"]],4,[1,["f6jmNaMtpPF70d+04Rl1Mr"]]],[21,["uiClientBetButton"],3,[1,["46KYvhA9ZE3qjr2v6DLRW2"]],3,[1,["ecwl+H+YBHAIcv7IOMmSi7","a3V6vEnvFFw7zUyzuX1g1n"]]],[21,["textureTable"],-108,[1,["80UNof4DVF6K+ImPnGble4"]],-107,[1,["90mHByaKpEALJWSljZyE4X"]]],[21,["subRoad"],5,[1,["54c3sbkWVI1rtr6LFM6/Vx"]],5,[1,["48ewTHPrVMu533k8JzU94P"]]]],[-100,-101,-102,-103,3,-104,-105,4,5,-106]],[65,[156,0.6,[2,0.242613,0.362617,0.798746,0],[2,0.241814,0.361945,0.798799,0],[2,0.23529411764705882,0.3607843137254902,0.796078431372549,0.6],[2,0.23529411764705882,0.3607843137254902,0.796078431372549,1]],[157,[4,4283190348]],[158,false,67,68],[159,[4,4292993505]],[66]]],[3,0,null,1,[4,"11d93zio1BqoCwuhQIFC4N",-111,[37,"4c/8DfcrpPj7gD5Grm0GMI",null,[[12,"PanelTextureTable",["_name"],[1,["11d93zio1BqoCwuhQIFC4N"]]],[9,["_lpos"],[1,["11d93zio1BqoCwuhQIFC4N"]],[1,0,0,0]],[9,["_lrot"],[1,["11d93zio1BqoCwuhQIFC4N"]],[3,0,0,0,1]],[9,["_euler"],[1,["11d93zio1BqoCwuhQIFC4N"]],[1,0,0,0]],[9,["_lpos"],[1,["0561maR5dDf6YRjC4qi40v"]],[1,0,0,0]]]],1]],[99,"PanelTest",false,33554432,1,[-114,6],[[13,-112,[5,1437,1080]],[136,-113]]],[119,"3DNode","37hqNdL2VFn4HKtXvA/WxW",17,[[-115,-116,[100,"手機平台架第二個Camera",-117],-118],1,1,4,1],[1,-1961.444,0,0]],[1,["1cGsAvu1ZBVZecqlfD+SZG"]],[1,["08EHpoiw9MMbzMb0cGOHBB"]],[1,["8fe3u7WjhHkIbsSZh4Gvyc"]],[101,"BG",33554432,19,[[13,-119,[5,300,126]],[140,0,-120,[4,1711276032],20],[147,1,3,3,3,-121]],[1,-554.715,471.852,0]],[71,"SpriteBigBG",33554432,1,[[13,-122,[5,1437,1080]],[141,0,-123,0]]],[3,0,null,1,[4,"96YvkyX2hOHooFOW7xBLSy",-124,[37,"bfIzUnNlFEPop4BT4DbUBO",null,[[12,"PanelTimer",["_name"],[1,["96YvkyX2hOHooFOW7xBLSy"]]],[9,["_lpos"],[1,["96YvkyX2hOHooFOW7xBLSy"]],[1,0,0,0]],[9,["_lrot"],[1,["96YvkyX2hOHooFOW7xBLSy"]],[3,0,0,0,1]],[9,["_euler"],[1,["96YvkyX2hOHooFOW7xBLSy"]],[1,0,0,0]]]],2]],[3,0,null,1,[4,"78FnrskSRPmJDtjOBKnSKo",-125,[37,"eaVQCEueFAp4PBv4/AV7kd",null,[[12,"PanelLimitBet",["_name"],[1,["78FnrskSRPmJDtjOBKnSKo"]]],[9,["_lpos"],[1,["78FnrskSRPmJDtjOBKnSKo"]],[1,0,0,0]],[9,["_lrot"],[1,["78FnrskSRPmJDtjOBKnSKo"]],[3,0,0,0,1]],[9,["_euler"],[1,["78FnrskSRPmJDtjOBKnSKo"]],[1,0,0,0]],[9,["_anchorPoint"],[1,["8c+P4qcq1Iv4DvA/4hHDVD"]],[0,0,0.5]],[9,["_lpos"],[1,["40DeV0a61LNqpsaVTkoD6k"]],[1,324.579,417.678,0]],[12,0,["_horizontalAlign"],[1,["79IJFa8O5OSYMM3p03THI5"]]],[12,"100-10,00022131231",["_string"],[1,["79IJFa8O5OSYMM3p03THI5"]]],[9,["_contentSize"],[1,["8c+P4qcq1Iv4DvA/4hHDVD"]],[5,218.71,50.4]]]],3]],[3,0,null,1,[4,"9bYa7kXVVETJ/fYwBpoGRl",-126,[37,"3dI6n61DpN3pgrWcLFhkiU",null,[[12,"PanelGameMessage",["_name"],[1,["9bYa7kXVVETJ/fYwBpoGRl"]]],[9,["_lpos"],[1,["9bYa7kXVVETJ/fYwBpoGRl"]],[1,0,0,0]],[9,["_lrot"],[1,["9bYa7kXVVETJ/fYwBpoGRl"]],[3,0,0,0,1]],[9,["_euler"],[1,["9bYa7kXVVETJ/fYwBpoGRl"]],[1,0,0,0]]]],4]],[3,0,null,1,[4,"7eIcbjSY1Gb5KE1pzoJf+6",-127,[37,"dfYHRUwMtAwJX6xQszqyl2",null,[[12,"PanelCoinState",["_name"],[1,["7eIcbjSY1Gb5KE1pzoJf+6"]]],[9,["_lpos"],[1,["7eIcbjSY1Gb5KE1pzoJf+6"]],[1,0,0,0]],[9,["_lrot"],[1,["7eIcbjSY1Gb5KE1pzoJf+6"]],[3,0,0,0,1]],[9,["_euler"],[1,["7eIcbjSY1Gb5KE1pzoJf+6"]],[1,0,0,0]],[12,true,["_active"],[1,["7eIcbjSY1Gb5KE1pzoJf+6"]]]]],9]],[3,0,{},1,[4,"cfmGXMVlBItJsf62+YPmCT",-128,[37,"5dOKzkkaVLbZqYV+tSubJ0",null,[[12,"PanelClientCoin",["_name"],[1,["cfmGXMVlBItJsf62+YPmCT"]]],[9,["_lpos"],[1,["cfmGXMVlBItJsf62+YPmCT"]],[1,0,0,0]],[9,["_lrot"],[1,["cfmGXMVlBItJsf62+YPmCT"]],[3,0,0,0,1]],[9,["_euler"],[1,["cfmGXMVlBItJsf62+YPmCT"]],[1,0,0,0]],[12,"999,9922",["_string"],[1,["290PbQNuJIBrotf5edleqX"]]],[9,["_contentSize"],[1,["06ea3J+0JM5Ji6BwKE5ymB"]],[5,141.81,50.4]],[12,2,["_horizontalAlign"],[1,["290PbQNuJIBrotf5edleqX"]]],[9,["_anchorPoint"],[1,["06ea3J+0JM5Ji6BwKE5ymB"]],[0,1,0.5]],[9,["_lpos"],[1,["13erPCMMdHI5oU7zDDbyZs"]],[1,-256.842,418.933,0]],[12,2,["_overflow"],[1,["290PbQNuJIBrotf5edleqX"]]],[12,31,["_actualFontSize"],[1,["290PbQNuJIBrotf5edleqX"]]],[12,true,["_active"],[1,["cfmGXMVlBItJsf62+YPmCT"]]],[9,["_lscale"],[1,["cfmGXMVlBItJsf62+YPmCT"]],[1,1,1,1]]]],10]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-129,[5,"29YXgWCABDkIHZbrThFoQc",5,[[12,"Player",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-595.2692492741602,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],14]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-130,[5,"58z3Tl7LVJs554eE+KJlIq",5,[[12,"Banker",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-396.01283284944014,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],15]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-131,[5,"d1B1AqmAtGn5K48m7LGY7M",5,[[12,"Tie",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-196.7564164247201,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],16]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-132,[5,"45UrddbahEa46ovaxHExHa",5,[[12,"PlayerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,2.499999999999943,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],17]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-133,[5,"76/aUDX1NBFYI8E9BvNGEF",5,[[12,"BankerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,201.75641642472,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],18]],[3,0,{},8,[4,"ebkOxRdWhDYJr+fC6yr/jp",-134,[5,"f5s4CFUphBV4eKXXt9JGgN",5,[[12,"PlayerAndBankerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,401.01283284944003,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],19]],[25,"Label",512,33554432,9,[[13,-135,[5,100,40]],[26,"回大廳",20,20,1,false,-136,[4,4278190080]]]],[25,"Label",512,33554432,10,[[13,-137,[5,100,40]],[26,"玩家下注",20,20,1,false,-138,[4,4278190080]]]],[25,"Label",512,33554432,11,[[13,-139,[5,100,40]],[26,"下注清空",20,20,1,false,-140,[4,4278190080]]]],[25,"Label",512,33554432,12,[[13,-141,[5,100,40]],[26,"參照上一把",20,20,1,false,-142,[4,4278190080]]]],[25,"Label",512,33554432,13,[[13,-143,[5,100,40]],[26,"確認下注",20,20,1,false,-144,[4,4278190080]]]],[25,"Label",512,33554432,14,[[13,-145,[5,100,40]],[26,"咪牌結束",20,20,1,false,-146,[4,4278190080]]]],[25,"Label",512,33554432,15,[[13,-147,[5,100,40]],[26,"咪牌過程",20,20,1,false,-148,[4,4278190080]]]],[25,"Label",512,33554432,16,[[13,-149,[5,100,40]],[26,"更新房間狀態",20,20,1,false,-150,[4,4278190080]]]],[102,"Sprite",false,33554432,1,[[13,-151,[5,1437,1080]],[142,-152,[4,3724541951],61]]],[71,"poly",33554432,1,[[76,-153],[169,-154,[[[0,-50,-50],[0,-50,50],[0,50,50],[0,50,-50]],8,8,8,8]]]],[3,0,null,20,[4,"7c5DSBsJdB/bjGDUeLWC1P",-155,[133,"24PtSfO49GvqAONheufnu5",null,[[12,"PanelTable",["_name"],[1,["7c5DSBsJdB/bjGDUeLWC1P"]]],[9,["_lpos"],[1,["7c5DSBsJdB/bjGDUeLWC1P"]],[1,0,0,0]],[9,["_lrot"],[1,["7c5DSBsJdB/bjGDUeLWC1P"]],[3,0,0,0,1]],[9,["_euler"],[1,["7c5DSBsJdB/bjGDUeLWC1P"]],[1,0,0,0]]],[[1,["bePgPbiC9ArZtMlNM79RFs"]]]],64]],[118,"Camera",33554432,1,[-156],[1,0,0,1000]],[67,0,1,571.9292763157895,2000,6,33554433,48,[4,4278190080]],[1,["75ivSr/D5FTqKEP8ZdgscS","8fe3u7WjhHkIbsSZh4Gvyc"]],[3,0,null,3,[4,"08EHpoiw9MMbzMb0cGOHBB",-157,[5,"29e4sfQjtPy5vOm54yyvNw",3,[[6,"UIClinetTableBetButton",["_name"],22],[0,["_lpos"],22,[1,0,0,0]],[0,["_lrot"],22,[3,0,0,0,1]],[0,["_euler"],22,[1,0,0,0]]]],7]],[3,0,null,3,[4,"8fe3u7WjhHkIbsSZh4Gvyc",-158,[5,"75ivSr/D5FTqKEP8ZdgscS",3,[[6,"UIBetFunctionButton",["_name"],23],[0,["_lpos"],23,[1,0,0,0]],[0,["_lrot"],23,[3,0,0,0,1]],[0,["_euler"],23,[1,0,0,0]]]],8]],[170,null,null],[1,["54c3sbkWVI1rtr6LFM6/Vx"]],[103,"Camera",20,[[163,"Camera<CameraComponent>",2000,2000,6,3,8,-159,[4,4286073907],62]],[1,0,-837.78,915.403],[3,0.29237170472273677,0,0,0.9563047559630354],[1,34,0,0]],[104,"Camera_Copy  馬的難調",false,20,[[164,"Camera<CameraComponent>",false,2000,2000,6,3,8,-160,[4,4286073907],63]],[1,0,-837.78,915.403],[3,0.29237170472273677,0,0,0.9563047559630355],[1,34,0,0]],[52,"Cube","2fShSrJ95NIbYewS7tVGGt",17,[[172,"Cube<ModelComponent>",-161,[65],[173],66]]]],0,[0,0,1,0,16,49,0,0,1,0,0,1,0,0,1,0,-1,48,0,-2,25,0,-3,18,0,-4,26,0,-5,27,0,-6,28,0,-7,3,0,-8,29,0,-9,30,0,-10,4,0,-11,5,0,-12,19,0,-13,45,0,-14,46,0,7,21,0,7,21,0,7,21,0,7,21,0,18,3,0,1,2,0,5,51,0,5,52,0,7,50,0,7,50,0,1,3,0,1,4,0,5,31,0,5,32,0,5,33,0,5,34,0,5,35,0,5,36,0,5,31,0,5,32,0,5,33,0,5,34,0,5,35,0,5,36,0,7,54,0,19,53,0,7,54,0,-1,53,0,1,5,0,0,6,0,0,6,0,-1,9,0,-2,10,0,-3,11,0,-4,12,0,-5,13,0,-6,14,0,-7,15,0,-8,16,0,0,7,0,0,9,0,0,9,0,11,9,0,0,9,0,-1,37,0,0,10,0,0,10,0,11,10,0,0,10,0,-1,38,0,0,11,0,0,11,0,11,11,0,0,11,0,-1,39,0,0,12,0,0,12,0,11,12,0,0,12,0,-1,40,0,0,13,0,0,13,0,11,13,0,0,13,0,-1,41,0,0,14,0,0,14,0,11,14,0,0,14,0,-1,42,0,0,15,0,0,15,0,11,15,0,0,15,0,-1,43,0,0,16,0,0,16,0,11,16,0,0,16,0,-1,44,0,-1,18,0,-2,26,0,-3,27,0,-4,28,0,-6,29,0,-7,30,0,-10,47,0,5,18,0,9,18,0,-3,20,0,-4,57,0,1,18,0,0,19,0,0,19,0,-1,24,0,-1,55,0,-2,56,0,10,20,0,-4,47,0,0,24,0,0,24,0,0,24,0,0,25,0,0,25,0,1,26,0,1,27,0,1,28,0,1,29,0,1,30,0,1,31,0,1,32,0,1,33,0,1,34,0,1,35,0,1,36,0,0,37,0,0,37,0,0,38,0,0,38,0,0,39,0,0,39,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,0,46,0,1,47,0,-1,49,0,1,51,0,1,52,0,0,55,0,0,56,0,0,57,0,17,17,1,10,17,2,10,3,6,10,19,7,10,17,161],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[3,2,2,2,2,2,2,2,2,2,2,2,2,19,2,2,2,2,2,2,3,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,6,12,13,14,3,20,20,2,-1,30,31,32],[47,48,49,50,51,52,15,14,16,53,54,55,56,0,3,3,3,3,3,3,8,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,1,1,1,4,5,57,13,13,58,59,60,61,62]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["71GEFzvI1Ijqd90EeqRHYX"]}],[3],0,[],[],[]],[[{"name":"bg_moneyend","rect":{"x":0,"y":0,"width":30,"height":18},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":18},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[63]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["74k+mBOm5IsoBHYb7IuvSD"]}],[3],0,[],[],[]],[[{"name":"bg_cphroad1_1","rect":{"x":0,"y":0,"width":884,"height":73},"offset":{"x":0,"y":0},"originalSize":{"width":884,"height":73},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[64]],[[[18,"PanelCoinState"],[19,"PanelCoinState",33554432,[-9,-10,-11,-12,-13],[[8,-2,[2,"efhSlivFJCOo7lfEyfb1tS"],[5,0,0]],[174,-8,[2,"53bYWy1rtKuJrBaUd9SPUL"],[-3,-4,-5,-6,-7]]],[7,"7eIcbjSY1Gb5KE1pzoJf+6",-1,0]],[34,"PlayerCoinState",33554432,1,[-16,-17,-18],[[[17,-14,[2,"eb+VUka/ZNHLxs8Pa8Vi5T"]],-15],4,1],[7,"c0ezj3OYNApJLFkSTb/lHa",1,0],[1,-373.472,54.072,0]],[34,"BankerCoinState",33554432,1,[-21,-22,-23],[[[17,-19,[2,"57I+rmIRJBRJ2+DZHg+IYn"]],-20],4,1],[7,"95O+QHLq9Fqqp4ZiKjN5I3",1,0],[1,381.1100000000001,54.072,0]],[34,"PlayerDoubleCoinState",33554432,1,[-26,-27,-28],[[[17,-24,[2,"ediSQrw/tCJou1pkI+26c/"]],-25],4,1],[7,"feBgRLhL1OQ41smZ6v4iau",1,0],[1,-225.902,351.289,0]],[34,"BankerDoubleCoinState",33554432,1,[-31,-32,-33],[[[17,-29,[2,"caSVKXiRpE/Iz6QT0Iz361"]],-30],4,1],[7,"3esV66FLFBtKQIVuCb07et",1,0],[1,229.31399999999996,352.289,0]],[34,"TieState",33554432,1,[-36,-37,-38],[[[17,-34,[2,"e2iqixqgdMFqgXC3ChH8p+"]],-35],4,1],[7,"65RH5ZkJ9A3Z+F9npO9yB/",1,0],[1,-0.583,18.448,0]],[14,"SpriteBG",33554432,2,[[8,-39,[2,"2cncv5RMZMaIGNdsqYEIHT"],[5,130,36]],[15,-40,[2,"e31AC7kKRCzaGhKIFucQZt"],0]],[7,"17d2Ft/d1Fk7KXnMburwL1",1,0]],[11,"SpriteCoin",33554432,2,[[8,-41,[2,"6bSwqU/StJeYyFY8YiReXz"],[5,30,18]],[15,-42,[2,"15lHUCNh5HZJbK9Y6tJtxs"],1]],[7,"95PepGjnJBe5vHgP3eiGPc",1,0],[1,-40,0,0]],[20,"LabelCoin",33554432,2,[[[8,-43,[2,"3dLJ3kWp9AGKp4u5JmhWKD"],[5,89.836,50.4]],-44],4,1],[7,"23l7+Q5fFBf5UbahvFtkJX",1,0],[1,17.196,0,0]],[14,"SpriteBG",33554432,3,[[8,-45,[2,"adQbaJ4/NNpZ6Wg9vCcKdU"],[5,130,36]],[15,-46,[2,"ddGPA0K6JAsanDw6Dhp6pb"],2]],[7,"d37NUBrldNUZ+3AKtnv4DV",1,0]],[11,"SpriteCoin",33554432,3,[[8,-47,[2,"d62S22/o1OgrItK5eNl+0z"],[5,30,18]],[15,-48,[2,"91pQfwOfJMQLyB9Qf+G70M"],3]],[7,"468mY5zvhMK5wYQzA8Wznu",1,0],[1,-40,0,0]],[20,"LabelCoin",33554432,3,[[[8,-49,[2,"2aagiIZoZJG62q5DurPiO7"],[5,89.836,50.4]],-50],4,1],[7,"65ojUjbT1AnbQ7JIqMkKKy",1,0],[1,17.196,0,0]],[14,"SpriteBG",33554432,4,[[8,-51,[2,"2evVPJnVhHRbFBApaeGrwH"],[5,130,36]],[15,-52,[2,"04pU/XmjtN4bqenE5xSiFo"],4]],[7,"ef/f+cfxhJ/IE1+psecS+1",1,0]],[11,"SpriteCoin",33554432,4,[[8,-53,[2,"55Y50fFWNBh4c5huk+O80g"],[5,30,18]],[15,-54,[2,"136jeQ3dNJ1o9Ktlif9jh/"],5]],[7,"d8ZWp41zFKcbunUda3shWj",1,0],[1,-40,0,0]],[20,"LabelCoin",33554432,4,[[[8,-55,[2,"5c2VCmMMNPzqTC3j3VAWf/"],[5,89.836,50.4]],-56],4,1],[7,"1ajRFf729AM6GCJIvCpIUy",1,0],[1,17.196,0,0]],[14,"SpriteBG",33554432,5,[[8,-57,[2,"193gQv63NEf5ZLNtgInjs6"],[5,130,36]],[15,-58,[2,"d3SIerjiROfLmJfNuJMqh3"],6]],[7,"4cwxfm8CVC85RxoU4Uak+j",1,0]],[11,"SpriteCoin",33554432,5,[[8,-59,[2,"d2mF68hBpPaqZnoy1WSu+v"],[5,30,18]],[15,-60,[2,"d24lNfO/VELqG4y11CtXl/"],7]],[7,"c9ssPOzfxGCbfZLIWfVnpT",1,0],[1,-40,0,0]],[20,"LabelCoin",33554432,5,[[[8,-61,[2,"c7hCikNFFKIZ1JLIXDnaAW"],[5,89.836,50.4]],-62],4,1],[7,"c5tBnZp+BDUbx45hFud3OA",1,0],[1,17.196,0,0]],[14,"SpriteBG",33554432,6,[[8,-63,[2,"822kTxRSpEAZnjHO4pS4G+"],[5,130,36]],[15,-64,[2,"9fJPFcfmRJC5wbPmmkNHgP"],8]],[7,"2awZnXMORI6rmfqQcbRtHa",1,0]],[11,"SpriteCoin",33554432,6,[[8,-65,[2,"f9uazOQ6NBIK4o1JXci5Mz"],[5,30,18]],[15,-66,[2,"72tjE20RNMQbvTG0l2MMv6"],9]],[7,"97vx19FHBHo7+Ryw2cqkOv",1,0],[1,-40,0,0]],[20,"LabelCoin",33554432,6,[[[8,-67,[2,"06Uq7zX2xN9p6gBfe3eIkE"],[5,89.836,50.4]],-68],4,1],[7,"81kJJCTaVK7Y0fEwO/4nYM",1,0],[1,17.196,0,0]],[43,"30033",30,30,2,false,9,[2,"f93bDiOGRPp5RINTssdWaP"],[4,4278190080]],[48,2,[2,"76Uq07DJNJq6+HSQZvroNm"],22],[43,"300",31,30,2,false,12,[2,"fa8IbKQgdPfYLue0oDcFtv"],[4,4278190080]],[48,3,[2,"5aAGAARt1InbId+ArR/QFY"],24],[43,"300",31,30,2,false,15,[2,"84aDM6R8VC7IUd452UVtpr"],[4,4278190080]],[48,4,[2,"06H00mcCxE3pt1DfPR+be3"],26],[43,"300",31,30,2,false,18,[2,"21dmw6KC9Lbo8cKaXOvOd+"],[4,4278190080]],[48,5,[2,"39GYjYIyVGZYrudM87Jlq/"],28],[43,"300",31,30,2,false,21,[2,"f7oG7rNt5DmqkRN0Kl6AKe"],[4,4278190080]],[48,6,[2,"9fX/139lJJfomKzMu37/Co"],30]],0,[0,1,1,0,0,1,0,-1,23,0,-2,25,0,-3,31,0,-4,27,0,-5,29,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,0,2,0,-2,23,0,-1,7,0,-2,8,0,-3,9,0,0,3,0,-2,25,0,-1,10,0,-2,11,0,-3,12,0,0,4,0,-2,27,0,-1,13,0,-2,14,0,-3,15,0,0,5,0,-2,29,0,-1,16,0,-2,17,0,-3,18,0,0,6,0,-2,31,0,-1,19,0,-2,20,0,-3,21,0,0,7,0,0,7,0,0,8,0,0,8,0,0,9,0,-2,22,0,0,10,0,0,10,0,0,11,0,0,11,0,0,12,0,-2,24,0,0,13,0,0,13,0,0,14,0,0,14,0,0,15,0,-2,26,0,0,16,0,0,16,0,0,17,0,0,17,0,0,18,0,-2,28,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,-2,30,0,8,1,68],[0,0,0,0,0,0,0,0,0,0,22,24,26,28,30],[3,3,3,3,3,3,3,3,3,3,15,15,15,15,15],[9,10,9,10,9,10,9,10,9,10,11,11,11,11,11]],[[[175,[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{"blend":false}]}}],[{"USE_TEXTURE":true}]]],0,0,[0],[21],[65]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["78qy2oMatCSof6/1gvdR5R"]}],[3],0,[],[],[]],[[{"name":"bg_horseman","rect":{"x":3,"y":0,"width":391,"height":47},"offset":{"x":-1,"y":0},"originalSize":{"width":399,"height":47},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[66]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["7dj5uJT9FMn6OrOOx83tfK"]}],[3],0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[67]],[[[18,"PanelLoading"],[19,"PanelLoading",33554432,[-5,-6],[[17,-2,[2,"d7iuyy6ndNWpy+12tqJolf"]],[137,0,-3,[2,"eby2c6911EvrZigwDMbJho"]],[177,-4,[2,"a4n0Cc/opPFZt+/NgmsU6F"]]],[7,"00SMMrGs9JqrE3ebXm06qN",-1,0]],[105,"ContentText",33554432,1,[-9,-10],[[8,-7,[2,"1eKGZ2fQZCTaeW8h/gofB0"],[5,254.49,100]],[35,1,1,5,-8,[2,"259lK6yztLk4zqeWdZqiQR"]]],[7,"94hdxrEFNPfayTnjkqikD+",1,0],[1,0.7,0.7,0.7]],[14,"SpriteBG",33554432,1,[[8,-11,[2,"4f65DbwvVHpoDfFb7ZLGyt"],[5,1431,10180]],[58,0,-12,[2,"4bjiIGXrtAiLceSldQsq1t"],[4,2147483648],0],[84,-13,[2,"249tIndYhAxrbH2CcNlPUL"]]],[7,"d4J6GECJ5Jm6uOY61Tu2/Q",1,0]],[11,"LabelText",33554432,2,[[10,-14,[2,"17x/uzBmJEsZFp04mKvlSx"],[5,180.04,40],[0,1,0.5]],[127,"LOADING",40,2,-15,[2,"68Po2H9dlHA6237RdYvLHp"]]],[7,"d1dVmGLwdKK7irbCyd/nF3",1,0],[1,52.79499999999999,0,0]],[11,"LabelDot",33554432,2,[[10,-16,[2,"deMgcgs/tFx6Y8CL+5O3YQ"],[5,69.45,50],[0,1,0.5]],[128,".....",50,50,50,2,-17,[2,"b5Bmu2+h1FkKumclADy3E6"]]],[7,"73t3ON2aNHwYqGkw/vBc7U",1,0],[1,127.24499999999999,0,0]]],0,[0,1,1,0,0,1,0,0,1,0,0,1,0,-1,3,0,-2,2,0,0,2,0,0,2,0,-1,4,0,-2,5,0,0,3,0,0,3,0,0,3,0,0,4,0,0,4,0,0,5,0,0,5,0,8,1,17],[0],[3],[8]],[[[90,"MicrosoftJhengHeiRegular-01","MicrosoftJhengHeiRegular-01.ttf"],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["84P1R7cFxMHoxr4wgTD4Vn"]}],[3],0,[],[],[]],[[{"name":"bg_Sline2","rect":{"x":0,"y":0,"width":355,"height":126},"offset":{"x":0,"y":0},"originalSize":{"width":355,"height":126},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[68]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["84cLcihGdNeKbe8zexzNPy"]}],[3],0,[],[],[]],[[{"name":"bg_cphiattice","rect":{"x":0,"y":0,"width":884,"height":616},"offset":{"x":0,"y":0},"originalSize":{"width":884,"height":616},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[69]],[[[18,"PanelVersion"],[19,"PanelVersion",33554432,[-4],[[8,-2,[2,"b6AqWmCCpMkIOjGgmp7pZd"],[5,0,0]],[178,-3,[2,"5ci538eVlFBqy/bjRUS4gu"]]],[7,"e6rSOiqj9LB7cxFfAzI2oi",-1,0]],[11,"LabelVersion",33554432,1,[[10,-5,[2,"acFqlZA45L5aqzEc+SfRAk"],[5,38.92,20],[0,1,0]],[129,"bata",2,20,20,20,2,-6,[2,"aahGFZdmpKu4lAsvjHjq9u"]]],[7,"ff6BZuThRCubSZp+xVI9dc",1,0],[1,715.057,-539.52,0]]],0,[0,1,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,8,1,6],[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["88kiIQmB5H949HmuBiH6bG"]}],[3],0,[],[],[]],[[{"name":"icon_suhperior3","rect":{"x":0,"y":0,"width":58,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":58,"height":58},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[70]],[[[18,"PanelTable"],[106,"PanelTable",[-5,-6,-7,-8],[[179,null,-4,[2,"8aOAUpM8BDeqdZKQggz0va"],-3,-2]],[7,"7c5DSBsJdB/bjGDUeLWC1P",-1,0]],[107,"SubWinSline",1,[-15,-16,-17,-18,-19],[[180,-14,[2,"d5LzlO9+JFUqfFD+V89QDM"],[-9,-10,-11,-12,-13]]],[7,"3fafbdtlFD4YHUBaGuoFyN",1,0]],[75,"SubTableText",1,[-21,-22,-23,-24,-25],[-20],[7,"fa7c9+jBhCbqetF+LlmoHs",1,0]],[75,"SubRatio",1,[-27,-28,-29,-30,-31],[-26],[7,"f67G2r12ZFdaPWzHpcmwzV",1,0]],[31,"LabelPlayerDouble",8,3,[[[8,-32,[2,"368vLtuh1DPod3kWKbGLts"],[5,111.4,129.4]],[24,-33,[2,"1bC+m7nDVPbb6QYk0FBRcA"]],-34,[45,1.7,-35,[2,"1dAAI4pqFHCa89BJ6g3NgQ"],[4,4294967295]]],4,4,1,4],[7,"0dPKm8hodAqYkIWUn14Lix",1,0],[1,-354.661,176.82,0],[1,1,1.15,1]],[31,"LabelPlayer",8,3,[[[8,-36,[2,"f5C5hrU3tNVoCSLyZ9AxJm"],[5,120.4,129.4]],[24,-37,[2,"5alVPqJXlF0YqOwNGt7nzN"]],-38,[45,1.7,-39,[2,"06sJPJEhJPEqred3FTPVrw"],[4,4294967295]]],4,4,1,4],[7,"79/7qxgEdAJLtDSh1sWOMc",1,0],[1,-330.75,-10.155,0],[1,1,1.15,1]],[31,"LabelTie",8,3,[[[8,-40,[2,"7ahGSgaNxD54LXczkPn04t"],[5,61.4,129.4]],[24,-41,[2,"33qQhWnn9Ojr+G/vdYd6wU"]],-42,[45,1.7,-43,[2,"de/mcn6qdJr6KI/ZBXsMEZ"],[4,4294967295]]],4,4,1,4],[7,"dbHWfRL0xD2qeUB/dcGkXj",1,0],[1,-1.0140000000000002,-86.544,0],[1,1,1.15,1]],[31,"LabelBanker",8,3,[[[8,-44,[2,"53ysF/wYZLNKE04jZKCXf9"],[5,120.4,129.4]],[24,-45,[2,"cb1US4VDtDIZ5sVEBS7SZe"]],-46,[45,1.7,-47,[2,"d8bb8SmTZMqajQ4H3TuKdY"],[4,4294967295]]],4,4,1,4],[7,"94S77FPmdPZ46syXLQ30SK",1,0],[1,330.75,-10.155,0],[1,1,1.15,1]],[31,"LabelBankerDouble",8,3,[[[8,-48,[2,"baYd0NtWlC2bePZfNSCPZr"],[5,111.4,129.4]],[24,-49,[2,"41l1dSOy1DF5adrwWdaJZF"]],-50,[45,1.7,-51,[2,"d86fC0l5lLNpVkNMnVq9cX"],[4,4294967295]]],4,4,1,4],[7,"93v9vv/ihDp7x11NVx3C3Q",1,0],[1,362.661,175.82,0],[1,1,1.15,1]],[108,"SpriteTable",8,1,[[8,-52,[2,"19zSsT0TFNx4O1extX4qHY"],[5,1203,652]],[24,-53,[2,"1dRWeGwOVGA5dxSXEMlsLJ"]],[143,2,-54,[2,"43Sucm69hCR6LWlU0c/JfY"],0,1]],[7,"d7iAtWDxpGEr0/BgGaGZ6L",1,0],[1,1,1.15,1]],[31,"SpritePlayerDouble",8,2,[[[8,-55,[2,"b9e/dj1jFKF7U/l1MYyuIp"],[5,351,126]],[24,-56,[2,"31Ve356TVHlZNwS2HkUM4p"]],-57],4,4,1],[7,"34/ctKG3dFE60GSEB9clCg",1,0],[1,-336.6680000000001,183.956,0],[1,1.02,1.18,1]],[31,"SpritePlayer",8,2,[[[8,-58,[2,"62Sh9PPM5Hbbi0pt1NEvur"],[5,424,317]],[24,-59,[2,"43S+FF3sRBc5gKLhIBdHil"]],-60],4,4,1],[7,"41P0NI7dFJI7ZX7HggRm35",1,0],[1,-299.7220000000002,-88.233,0],[1,1.03,1.19,1]],[31,"SprtieTie",8,2,[[[8,-61,[2,"0cawq4e4NI2rjZ4Lnhjg3c"],[5,360,216]],[24,-62,[2,"57HplvT/lIYa7q9gOvAd0T"]],-63],4,4,1],[7,"d1OHygDBVN+qOuopltzYyh",1,0],[1,2,-147.876,0],[1,1.02,1.18,1]],[31,"SprtieBanker",8,2,[[[8,-64,[2,"f4DFDTOXZExbDPl4siU9+J"],[5,428,317]],[24,-65,[2,"edl4nTmP9FIZvyc2NKU2Jk"]],-66],4,4,1],[7,"79qi0D5BRA+b8GR3GahUfL",1,0],[1,306.722,-87.233,0],[1,1.03,1.19,1]],[31,"SprtieBankerDouble",8,2,[[[8,-67,[2,"feJhaB0JlNP7CO4UTP73Ty"],[5,355,126]],[24,-68,[2,"3eTBHgKGBB27jzxV8XseV5"]],-69],4,4,1],[7,"e6Wx4YPqlN8YLpdXgzMEWG",1,0],[1,342.6680000000001,183.956,0],[1,1.02,1.18,1]],[32,"LabelPlayerDouble",8,4,[[8,-70,[2,"bb0OZK2ddIF5jDrXkE+Tnj"],[5,56.16,126]],[24,-71,[2,"cbrjsJgzdI1JoxI/AlCsfD"]],[36,"1:11",30,30,100,-72,[2,"29iSNqhhVAhryQmvb3K55o"]]],[7,"39crSPs2JKOIgGb4yB8Ihh",1,0],[1,-229.1619999999998,159.769,0],[1,1,1.15,1]],[32,"LabelPlayer",8,4,[[8,-73,[2,"3b6f/hdRxF9o4IfYGtEoBZ"],[5,41.7,126]],[24,-74,[2,"7cKd8sa0RBpou4HxiG5+Wb"]],[36,"1:1",30,30,100,-75,[2,"4elkJB7z1JY4Fh6aqvW2qH"]]],[7,"063XRGu8hLJYgk3TeytH6b",1,0],[1,-330.75,-110.769,0],[1,1,1.15,1]],[32,"LabelTie",8,4,[[8,-76,[2,"84V3PrJFxK34i3VPSTLr53"],[5,41.7,126]],[24,-77,[2,"08lY12UNtD0oxIVxBEuKgB"]],[36,"1:8",30,30,100,-78,[2,"6c1YNcj/1JEZPgb7sooq5R"]]],[7,"b8U3Kg5yxN1JHvWGRMs2fy",1,0],[1,-1.0139999999998963,-154.49,0],[1,1,1.15,1]],[32,"LabelBanker",8,4,[[8,-79,[2,"ceTW9RVg9MXJRpGp6aRYCe"],[5,41.7,126]],[24,-80,[2,"14qWNmNz9Jo5muFcAXHb9g"]],[36,"1:1",30,30,100,-81,[2,"73aas50mdIoLYQVxIiwp1j"]]],[7,"80Xlg//qVJoYgePOm1Wmd/",1,0],[1,330.75,-110.769,0],[1,1,1.15,1]],[32,"LabelBankerDouble",8,4,[[8,-82,[2,"66gbp9mShOg78boFVZirNh"],[5,56.16,126]],[24,-83,[2,"cdqOIRVXNJ2oJYLJJ7BFw7"]],[36,"1:11",30,30,100,-84,[2,"9bDv5UoI9FhZtL7c5kEppp"]]],[7,"48s/LXMXFESoYGQYsm6ZFJ",1,0],[1,218.16200000000003,160.769,0],[1,1,1.15,1]],[40,2,11,[2,"e5A2izC4NFc5qWNo31EZR6"]],[40,2,12,[2,"53NEBXWK1Jd7CnNpnGxQs0"]],[40,2,13,[2,"f3YZ4dCN1B4I7xVBe5Sw23"]],[40,2,14,[2,"bdYdtJtj5CEKZMs0DpTYm7"]],[40,2,15,[2,"c4nLUtY5dLqoKSzSIepdpR"]],[56,"閒對",54,54,100,true,5,[2,"02eiBQjFZLdam0CuM2AbUl"],[4,4293093135]],[56,"閒",117,117,100,true,6,[2,"6fPJ3/zOVMKZp2pM5ZP0Na"],[4,4293093135]],[56,"和",58,58,100,true,7,[2,"56alyKyWtHZYbqbIhm4r3l"],[4,4293093135]],[81,"莊",117,117,100,false,true,8,[2,"8aVY+bphVKzJFLOj1pfVem"],[4,4293093135]],[81,"莊對",54,54,100,false,true,9,[2,"f1bcCmRohKCr5golT1zQvl"],[4,4293093135]],[181,3,[2,"3cq/e1uwRFeYi5A6/hUWxt"],[27,29,28,26,30]],[182,4,[2,"d00QSfI0tCM437NVYEDeXa"]]],0,[0,1,1,0,33,32,0,34,31,0,0,1,0,-1,10,0,-2,2,0,-3,3,0,-4,4,0,-1,22,0,-2,24,0,-3,23,0,-4,21,0,-5,25,0,0,2,0,-1,11,0,-2,12,0,-3,13,0,-4,14,0,-5,15,0,-1,31,0,-1,5,0,-2,6,0,-3,7,0,-4,8,0,-5,9,0,-1,32,0,-1,16,0,-2,17,0,-3,18,0,-4,19,0,-5,20,0,0,5,0,0,5,0,-3,26,0,0,5,0,0,6,0,0,6,0,-3,27,0,0,6,0,0,7,0,0,7,0,-3,28,0,0,7,0,0,8,0,0,8,0,-3,29,0,0,8,0,0,9,0,0,9,0,-3,30,0,0,9,0,0,10,0,0,10,0,0,10,0,0,11,0,0,11,0,-3,21,0,0,12,0,0,12,0,-3,22,0,0,13,0,0,13,0,-3,23,0,0,14,0,0,14,0,-3,24,0,0,15,0,0,15,0,-3,25,0,0,16,0,0,16,0,0,16,0,0,17,0,0,17,0,0,17,0,0,18,0,0,18,0,0,18,0,0,19,0,0,19,0,0,19,0,0,20,0,0,20,0,0,20,0,8,1,84],[0,0,22,23,24,25,29,30],[35,3,3,3,3,3,15,15],[71,72,73,74,75,76,17,17]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["8alTtAupxNEo2P97mR7FvF"]}],[3],0,[],[],[]],[[{"name":"bg_iattice2","rect":{"x":0,"y":0,"width":316,"height":127},"offset":{"x":0,"y":0},"originalSize":{"width":316,"height":127},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[77]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["8dlExriq5DrKB41muGXsTe"]}],[3],0,[],[],[]],[[{"name":"bg_Sline5","rect":{"x":0,"y":0,"width":428,"height":317},"offset":{"x":0,"y":0},"originalSize":{"width":428,"height":317},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[78]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[3],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[2],0,[0],[4],[79]],[[[90,"MicrosoftJhengHeiBold-01","MicrosoftJhengHeiBold-01.ttf"],-1],0,0,[],[],[]],[[[61,"Lobby"],[51,"Canvas",33554432,"dd+NXlYc1AiqC65cOiD0iN",[-5,-6,-7,-8],[[13,-1,[5,1431,1080]],[62,-3,-2],[63,45,-4]],[1,715.5,540,0]],[70,"Button",33554432,1,[-14],[[13,-9,[5,100,40]],[28,1,0,-10,0],[29,2,-13,[[30,"653bbdPZ3RDmKpDCzluqRM3","inRoomLevel",-12]],[4,4292269782],-11,1,2,3,4]]],[33,"Button-001",33554432,1,[-20],[[13,-15,[5,100,40]],[28,1,0,-16,5],[29,2,-19,[[30,"653bbdPZ3RDmKpDCzluqRM3","inGame",-18]],[4,4292269782],-17,6,7,8,9]],[1,0,-135.385,0]],[33,"Button-002",33554432,1,[-26],[[13,-21,[5,100,40]],[28,1,0,-22,10],[29,2,-25,[[30,"653bbdPZ3RDmKpDCzluqRM3","inLobby",-24]],[4,4292269782],-23,11,12,13,14]],[1,0,94.359,0]],[64,"Lobby",[-27,-28,1,-29],[123,"a6be183e-e1e8-49c5-81b4-6d6021a69d89"],[65,[86,[2,0,0,0,0.520833125],[2,0,0,0,0]],[87,1,30,[4,4283190348]],[88],[89],[66]]],[52,"MainLobby","88TxmLJ2ZGzryZyfFysCiZ",5,[[183,-30]]],[25,"Label",512,33554432,2,[[13,-31,[5,100,40]],[26,"進級別房",20,20,1,false,-32,[4,4278190080]]]],[25,"Label",512,33554432,3,[[13,-33,[5,100,40]],[26,"進遊戲",20,20,1,false,-34,[4,4278190080]]]],[25,"Label",512,33554432,4,[[13,-35,[5,100,40]],[26,"返回大廳",20,20,1,false,-36,[4,4278190080]]]],[109,"Main Camera","c9DMICJLFO5IeO07EPon7U",5,[[165,1822425087,-37]],[1,0,0,2.76]],[74,"Camera",1,[-38],[1,0,0,1000]],[67,0,1073741824,540,2000,6,41943040,11,[4,4278190080]],[52,"Node","10tXrlToxEt43wJakig3NN",5,[[76,-39]]]],0,[0,0,1,0,16,12,0,0,1,0,0,1,0,-1,11,0,-2,2,0,-3,3,0,-4,4,0,0,2,0,0,2,0,11,2,0,5,6,0,0,2,0,-1,7,0,0,3,0,0,3,0,11,3,0,5,6,0,0,3,0,-1,8,0,0,4,0,0,4,0,11,4,0,5,6,0,0,4,0,-1,9,0,-1,10,0,-2,6,0,-4,13,0,0,6,0,0,7,0,0,7,0,0,8,0,0,8,0,0,9,0,0,9,0,0,10,0,-1,12,0,0,13,0,17,5,1,10,5,39],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[3,6,12,13,14,3,6,12,13,14,3,6,12,13,14],[1,1,1,4,5,1,1,1,4,5,1,1,1,4,5]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["a97nDcFINM+pOlGxtXV7g0"]}],[3],0,[],[],[]],[[{"name":"lby_table5","rect":{"x":0,"y":0,"width":137,"height":137},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":137},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[80]],[[[18,"PrefabCurrntRoadItem"],[72,"PrefabCurrntRoadItem",33554432,[-7,-8],[[10,-2,[2,"a9xUmS03VLAoqw3Qs9/xOm"],[5,194.25641642472004,100],[0,0,0.5]],[35,1,1,8,-3,[2,"52ISc2OrZPRbEHGX197Irm"]],[184,-6,[2,"9cvc7O0MxCh48Fx1C5aQaH"],-5,-4]],[7,"ebkOxRdWhDYJr+fC6yr/jp",-1,0],[1,0,-477.669,0]],[54,"Title",33554432,1,[[[10,-9,[2,"194XSk+pxPTJ70V3YodvJK"],[5,59.9,59.9],[0,0,0.5]],-10],4,1],[7,"417Dj6OQJJxKYilHOxegdi",1,0]],[20,"Label_Number",33554432,1,[[[10,-11,[2,"8eGtagAuZLy4P3d4dfG6hM"],[5,126.35641642472004,50.4],[0,0,0.5]],-12],4,1],[7,"cc1CjLay9OKKatwjQXSDUq",1,0],[1,67.9,1.4210854715202004e-14,0]],[40,0,2,[2,"6fmbJ5T2dF7a6OEHT1UCJu"]],[130,"22123",0,45,80,80,2,3,[2,"d4u8t3ws9Ek7SXNqM9vcgo"]]],0,[0,1,1,0,0,1,0,0,1,0,36,5,0,37,4,0,0,1,0,-1,2,0,-2,3,0,0,2,0,-2,4,0,0,3,0,-2,5,0,8,1,12],[4],[3],[81]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["abZDzJnmROO7GV7L1x6BsE"]}],[3],0,[],[],[]],[[{"name":"bg_amount","rect":{"x":0,"y":0,"width":210,"height":38},"offset":{"x":0,"y":0},"originalSize":{"width":210,"height":38},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[82]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["acDvw4R09CgrPQPXKjzSt0"]}],[3],0,[],[],[]],[[{"name":"bg_Sline4","rect":{"x":0,"y":0,"width":360,"height":216},"offset":{"x":0,"y":0},"originalSize":{"width":360,"height":216},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[83]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["ac9+NqrJZO6aJpc7iP2NYJ"]}],[3],0,[],[],[]],[[{"name":"icon_cphsuhperior2","rect":{"x":0,"y":0,"width":27,"height":26},"offset":{"x":0,"y":0},"originalSize":{"width":27,"height":26},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[84]],[[[18,"PanelTextureTable"],[110,"PanelTextureTable",[-3],[[185,null,-2,[2,"80UNof4DVF6K+ImPnGble4"]]],[7,"11d93zio1BqoCwuhQIFC4N",-1,0],[1,-715.5,-540,0]],[11,"TextureTable",33554432,1,[[8,-4,[2,"360TGC84dODqyoT0qiJTt6"],[5,1431,1080]],[16,2,-5,[2,"90mHByaKpEALJWSljZyE4X"],0]],[7,"0561maR5dDf6YRjC4qi40v",1,0],[1,715.5,540,0]]],0,[0,1,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,8,1,5],[0],[3],[18]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["b5NZRMe7NDnI3mXUgOruvP"]}],[3],0,[],[],[]],[[{"name":"pc_1","rect":{"x":0,"y":0,"width":1437,"height":1080},"offset":{"x":0,"y":0},"originalSize":{"width":1437,"height":1080},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[85]],[[[18,"UIClinetTableBetButton"],[19,"UIClinetTableBetButton",33554432,[-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22],[[17,-2,[2,"03mvW3nKZOyarmxm+qliv1"]],[186,-9,[2,"17RXaM4P9HZKWFYltOqkf2"],[-4,-5,-6,-7,-8],-3],[39,-10,[2,"355rihgatJQJpQ5Lje2UFn"]]],[7,"08EHpoiw9MMbzMb0cGOHBB",-1,0]],[11,"OnPlayerDouble",33554432,1,[[8,-23,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,384.38,106.19199999999998]],[47,true,-24,[2,"9a9nOVL+tFsKXFjUDgvd3G"],[[[0,-180.8,-46.5],[0,-162.7,21.5],[0,-148.7,38.7],[0,-123.2,47.9],[0,184,49.2],[0,175.6,-51.1]],8,8,8,8,8,8]]],[7,"67aA00eQFLHbWG1FWeeViA",1,0],[1,-335.604,326.50800000000004,0]],[11,"OnPlayer",33554432,1,[[8,-25,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,491.0069999999999,346.69399999999996]],[47,true,-26,[2,"80zMn5f85L3rKjGQvjrLLk"],[[[0,-227.6,42],[0,-193.8,157.1],[0,169.8,156.6],[0,185.2,103.9],[0,241.7,67.6],[0,104.4,-166],[0,-58.7,-162.9],[0,-140.6,-134.2],[0,-217.4,-55.1]],8,8,8,8,8,8,8,8,8]]],[7,"bblBpOBe5OdJSPC+JTvtgD",1,0],[1,-332.494,110.501,0]],[11,"OnBanker",33554432,1,[[8,-27,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,491.007,346.694]],[47,true,-28,[2,"2eTUU3Ir5EP7bgcRiKlAT+"],[[[0,-99.1,-157.1],[0,-239.7,74.3],[0,-181.8,110.6],[0,-168,164.7],[0,198.5,165.6],[0,232.2,59.4],[0,232.1,-24.5],[0,156.9,-123.5],[0,51.9,-156.9]],8,8,8,8,8,8,8,8,8]]],[7,"adz00O6DxOaZCg+PcHqBjT",1,0],[1,334.805,103.715,0]],[11,"OnBankerDouble",33554432,1,[[8,-29,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,384.38,106.192]],[47,true,-30,[2,"c4yUi1aQZEiYYr39Bi18Wn"],[[[0,-177.2,-51],[0,-186.3,48.8],[0,122.8,49],[0,146,41.4],[0,164.5,23.7],[0,188.4,-49.2]],8,8,8,8,8,8]]],[7,"e6TtBrD+xLIq1QMT8ox4qA",1,0],[1,340.851,326.979,0]],[11,"OnTie",33554432,1,[[8,-31,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,454.6199999999999,304.299]],[47,true,-32,[2,"fd9TN/H5RPEqjHID0R9gAE"],[[[0,-217.5,-97.7],[0,-85,129.9],[0,85.2,130.8],[0,220.6,-99]],8,8,8,8]]],[7,"03mPZh/ctCvqv3KhC5/4r6",1,0],[1,2.003,44.8125,0]],[14,"demo",33554432,1,[[8,-33,[2,"a1mnn2b9NCTIPwvv+Wx37e"],[5,1431,1080]],[144,false,-34,[2,"36ME0WwoNP9JAFRVBpg4vm"],0]],[7,"914WF3kV1NiYHpQpdxL3Fr",1,0]],[14,"ChipContent",33554432,1,[[17,-35,[2,"81LUeVDjNG3ZHnI7urj7Vt"]]],[7,"e3bhFEYJFGWb6jF7ROL06t",1,0]],[11,"RangeTie",33554432,1,[[8,-36,[2,"a9xafDaclLTrODIzWQCYm3"],[5,178.60399999999998,218.899]]],[7,"dddx0BjdNIIpzZDWG/vHJP",1,0],[1,0,59.4495,0]],[11,"RangeBanker",33554432,1,[[8,-37,[2,"3fZh7LehlBnJ6mhBZplJi3"],[5,293.584,218.899]]],[7,"05BLllIKpDwZ9TxFhPwqJY",1,0],[1,360.617,130.004,0]],[11,"RangePlayer",33554432,1,[[8,-38,[2,"4biDwLTZlADpNrPva8EtlU"],[5,293.584,218.899]]],[7,"0d6Hj4GdhKZ4sMPNtyQFlm",1,0],[1,-360.617,130.004,0]],[11,"RangePlayerDouble",33554432,1,[[8,-39,[2,"b6yeEq5VxEnIn0mnwx4Y/x"],[5,310.57,85.62800000000001]]],[7,"87GL5ft71J/IzVoRXVOpIT",1,0],[1,-315.54,332.5245,0]],[11,"RangeBankerDouble",33554432,1,[[8,-40,[2,"5chtPBf8BJSaAuPmi9qlTO"],[5,310.57,85.62800000000001]]],[7,"71izyA+X5GXqbgimZXG4SQ",1,0],[1,327.63,332.524,0]]],0,[0,1,1,0,0,1,0,38,8,0,-1,3,0,-2,4,0,-3,6,0,-4,2,0,-5,5,0,0,1,0,0,1,0,-1,7,0,-2,9,0,-3,10,0,-4,11,0,-5,12,0,-6,13,0,-7,2,0,-8,3,0,-9,4,0,-10,5,0,-11,6,0,-12,8,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,0,4,0,0,5,0,0,5,0,0,6,0,0,6,0,0,7,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,0,12,0,0,13,0,8,1,40],[0],[3],[18]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["c7Btmx8N5ChK6kk6N7CMHB"]}],[3],0,[],[],[]],[[{"name":"lby_table2","rect":{"x":0,"y":0,"width":137,"height":137},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":137},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[86]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[16],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[[176,[{}],[{}]]],0,0,[0],[21],[87]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["d5+hfakm9ERbLfLFobVDcL"]}],[3],0,[],[],[]],[[{"name":"bg_cellphone2","rect":{"x":0,"y":0,"width":884,"height":750},"offset":{"x":0,"y":0},"originalSize":{"width":884,"height":750},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[88]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["dblooaYXZDMpMLWxA8Txkd"]}],[3],0,[],[],[]],[[{"name":"lby_table4","rect":{"x":0,"y":0,"width":137,"height":137},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":137},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[89]],[[[18,"PanelClientCoin"],[19,"PanelClientCoin",33554432,[-5,-6,-7],[[8,-2,[2,"81et/ZFtVCb573PCvutB4W"],[5,0,0]],[187,-4,[2,"e5/Das+sVJg5e1OT6V9xc2"],-3]],[7,"cfmGXMVlBItJsf62+YPmCT",-1,0]],[11,"SpriteBG",33554432,1,[[8,-8,[2,"cega2Ra+dEZpPDiMUEXp4r"],[5,210,38]],[15,-9,[2,"b9H/FOEz9DB70DtAnjArlT"],0]],[7,"18WnmyzLlGppc+kVV4WEfO",1,0],[1,-351.058,417.907,0]],[11,"SpriteCoin",33554432,1,[[8,-10,[2,"a22ofUuq5A4YYpTPh0W4Ly"],[5,25,23]],[15,-11,[2,"e8myCJr7ZBgpkw/YLrXhvB"],1]],[7,"44EQl1sJRChpzHdM3nVt+y",1,0],[1,-427.091,417.795,0]],[20,"LabelCoin",33554432,1,[[[8,-12,[2,"06ea3J+0JM5Ji6BwKE5ymB"],[5,108.44,50.4]],-13],4,1],[7,"13erPCMMdHI5oU7zDDbyZs",1,0],[1,-318.57,418.933,0]],[131,"999,999",30,30,4,[2,"290PbQNuJIBrotf5edleqX"],[4,4284794879]]],0,[0,1,1,0,0,1,0,39,5,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,-2,5,0,8,1,13],[0,0],[3,3],[90,91]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["e2tSuyU+5ERo+E/KrC4+jb"]}],[3],0,[],[],[]],[[{"name":"bg_table","rect":{"x":9,"y":11,"width":1184,"height":632},"offset":{"x":-0.5,"y":-1},"originalSize":{"width":1203,"height":652},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[2],0,[0],[4],[92]],[[[18,"UITabelChipContent"],[111,"UITabelChipContent",33554432,[[17,-2,[2,"8aTeAs/TdOjamSwGAtq1ub"]],[188,-3,[2,"2bqedwR+pLSbdz/oOfJiXM"]]],[7,"11ESLde4xL1bL911jpKNiy",-1,0]]],0,[0,1,1,0,0,1,0,0,1,0,8,1,3],[],[],[]],[[[18,"PanelCardSequence_Phone"],[19,"PanelCardSequence_Phone",33554432,[-229,-230,-231,-232],[[17,-224,[2,"93/EjgKMBEkaz96SmPsqXy"]],[189,-228,[2,"e0vM7+niRPPp4mE5WDEevF"],-227,-226,-225]],[77,"4aEKBj3cVCArIMFwhj85in",-223,0,[[22,["labelContent","0"],-200,-199,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["labelContent","1"],-202,-201,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["labelContent","2"],-204,-203,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["labelContent","3"],-206,-205,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["labelContent","4"],-208,-207,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["labelContent","5"],-210,-209,[1,["d4u8t3ws9Ek7SXNqM9vcgo"]]],[22,["itemContent","0"],-212,-211,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[22,["itemContent","1"],-214,-213,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[22,["itemContent","2"],-216,-215,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[22,["itemContent","3"],-218,-217,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[22,["itemContent","4"],-220,-219,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]],[22,["itemContent","5"],-222,-221,[1,["9cvc7O0MxCh48Fx1C5aQaH"]]]],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162,-163,-164,-165,-166,-167,-168,-169,-170,-171,-172,-173,-174,-175,-176,-177,-178,-179,-180,-181,-182,-183,-184,-185,-186,-187,-188,-189,-190,-191,-192,-193,-194,-195,-196,-197,-198]]],[19,"Node",33554432,[-235,-236,-237,-238,-239,-240,-241,-242,-243,-244,-245,-246,-247,-248,-249,-250,-251,-252,-253,-254,-255,-256,-257,-258,-259,-260,-261,-262,-263,-264,-265,-266,-267,-268,-269,-270,-271,-272,-273,-274,-275,-276,-277,-278,-279,-280,-281,-282,-283,-284,-285,-286,-287,-288,-289,-290,-291,-292,-293,-294,-295,-296,-297,-298,-299,-300,-301,-302,-303,-304,-305,-306,-307,-308,-309,-310,-311,-312,-313,-314,-315,-316,-317,-318,-319,-320,-321,-322,-323,-324,-325,-326,-327,-328,-329,-330,-331,-332,-333,-334,-335,-336,-337,-338,-339,-340,-341,-342,-343,-344,-345,-346,-347,-348,-349,-350,-351,-352,-353,-354,-355,-356,-357,-358,-359,-360,-361,-362,-363,-364,-365,-366,-367,-368,-369,-370,-371,-372,-373,-374,-375,-376,-377,-378,-379,-380,-381,-382,-383,-384,-385,-386,-387,-388,-389,-390,-391,-392,-393,-394,-395,-396,-397,-398,-399,-400,-401,-402,-403,-404,-405,-406,-407,-408,-409,-410,-411,-412,-413,-414,-415,-416,-417,-418,-419,-420,-421,-422,-423,-424,-425,-426],[[10,-233,[2,"7eMN8utMBOuJ/ucfzHZPJf"],[5,1420.0459999999998,100],[0,0,1]],[148,3,3.52,3.57,5.77,6.3,-234,[2,"a3SpHBALhDCqt2cdqwroiu"]]],[7,"95Rg8pSy9MOob4IpK3SzKq",1,0]],[190,[null,null,null,null,null,null],[2,"93cS/yqXhKEaKUlnzbGM64"]],[55,"SubDerailRoad",33554432,1,[-429,-430,-431,-432,-433,-434,-435,-436,-437],[[[17,-427,[2,"2dy9qAoLNKaLJb2ksQXkRh"]],-428],4,1],[7,"9aTQdvpbZLe7aCegNxsEsv",1,0]],[19,"content",33554432,[-440,-441,-442,-443,-444],[[10,-438,[2,"b5WD1KZoZPfawcxyT65kay"],[5,1717.3,139],[0,0,1]],[35,1,1,-1.3,-439,[2,"7ahNJCuANC6JVLJ6g6QbNf"]]],[7,"60S7JoqftKyY+1ohLsIeJo",1,0]],[72,"Content",33554432,[-447,-448,-449,-450,-451,-452],[[8,-445,[2,"14aHSThY1JwJFmCw4k/qXC"],[5,1190.5384985483204,100]],[35,1,1,5,-446,[2,"14Z6zkXpZLnYEcnv8Lys0Q"]]],[7,"e91YQEGmRBlZfVUZSHWFkQ",1,0],[1,-39.557,-477.669,0]],[19,"contentSpriteBG",33554432,[-455,-456,-457],[[10,-453,[2,"58TRBGn+dNX4qkpRGaGgIL"],[5,2061,279],[0,0,1]],[35,1,1,-1.5,-454,[2,"92dX0dINxNIaEegNNFX8Lu"]]],[7,"94v0ws0bdDbLGMLEAO+wVk",1,0]],[19,"contentSpriteBG",33554432,[-460,-461,-462],[[10,-458,[2,"b0t7wOTK9DKJ9HP6AnDkGO"],[5,2061,279],[0,0,1]],[35,1,1,-1.5,-459,[2,"c170I/tS9NkrplpRsKCupe"]]],[7,"4e6NYm89xMK6ih4p9kZUz/",1,0]],[19,"content",33554432,[-465,-466,-467],[[10,-463,[2,"b2ou8V/gBMVpA77c59lQCF"],[5,1030.9,139],[0,0,1]],[35,1,1,-1.3,-464,[2,"f699XEs0hG9YiToNM3a1CQ"]]],[7,"c6HHE8N5RIKJjugLHRoyzg",1,0]],[19,"content",33554432,[-470,-471,-472],[[10,-468,[2,"02Y70U8jRNFK8txJ1j/EoH"],[5,1030.9,139],[0,0,1]],[35,1,1,-1.3,-469,[2,"3e7XQnFm5AjYq+ifglQJbc"]]],[7,"54EiMID0hPy6RatGJQMXQ0",1,0]],[34,"SubRoad",33554432,4,[-476],[[[10,-473,[2,"b7+XO//59NP4v2hBBLfyFV"],[5,1431,279],[0,0,1]],[49,0.23,0.75,false,-474,[2,"08z7LQZi9PTrp3Wzh+KsIA"],7],-475],4,4,1],[7,"41ccvAHopAF7jgCaibCg6I",1,0],[1,-715.5,416,0]],[38,"view",33554432,11,[7,-479],[[10,-477,[2,"d53U7vMGFMPq4JdUdxYGF+"],[5,1431,279],[0,0,1]],[46,false,-478,[2,"c1TVTZUMBKF5KzaDMDlDHz"]]],[7,"91GOKtPKtBlZgtrx+EzzzZ",1,0]],[34,"BigRoad",33554432,4,[-483],[[[10,-480,[2,"d1kUSC+6pAirl1wyLd13ws"],[5,1431,279],[0,0,1]],[49,0.23,0.75,false,-481,[2,"1cGgYbyhZLjriZE68nck/W"],8],-482],4,4,1],[7,"507iPN3ZFDsa0aWJi4aqTb",1,0],[1,-715.5,139,0]],[38,"view",33554432,13,[8,-486],[[10,-484,[2,"3bu6c0l+lG5rzEue7rjfkC"],[5,1431,279],[0,0,1]],[46,false,-485,[2,"a06KQSdpxHmansDuLU7gfo"]]],[7,"a4S4eTWFRIXIWx16abe+vV",1,0]],[55,"SubSimpleRoad",33554432,1,[-488,6],[[[17,-487,[2,"dfJZUFfG9Ew4rvos39Jz1q"]],3],4,1],[7,"90PoENCQNPrIp8Arv2mlvJ",1,0]],[116,"icon_suhperior3",33554432,[-492],[[[8,-489,[2,"687YGSHDRMhqv+rICzDaxD"],[5,58,58]],[15,-490,[2,"bcYraae5VLR7jFiemKoyDI"],214],-491],4,4,1],[7,"980LAHY5lK1qhKTKn0C6Ry",1,0],[1,362.564,0,0]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-493,[5,"29YXgWCABDkIHZbrThFoQc",1,[[12,"Player",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-595.2692492741602,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],216]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-494,[5,"58z3Tl7LVJs554eE+KJlIq",1,[[12,"Banker",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-396.01283284944014,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],217]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-495,[5,"d1B1AqmAtGn5K48m7LGY7M",1,[[12,"Tie",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,-196.7564164247201,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],218]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-496,[5,"45UrddbahEa46ovaxHExHa",1,[[12,"PlayerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,2.499999999999943,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],219]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-497,[5,"76/aUDX1NBFYI8E9BvNGEF",1,[[12,"BankerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,201.75641642472,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],220]],[3,0,{},6,[4,"ebkOxRdWhDYJr+fC6yr/jp",-498,[5,"f5s4CFUphBV4eKXXt9JGgN",1,[[12,"PlayerAndBankerDouble",["_name"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]]],[9,["_lpos"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,401.01283284944003,0,0]],[9,["_lrot"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[3,0,0,0,1]],[9,["_euler"],[1,["ebkOxRdWhDYJr+fC6yr/jp"]],[1,0,0,0]]]],221]],[55,"SubGameState",33554432,1,[-501,-502],[[[17,-499,[2,"b22tYDAkRDoIwW/cBL/CKw"]],-500],4,1],[7,"e9mpluQhZHQL7+pJwNHrIU",1,0]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[1,["d1LLgj3plJr7BgjvhEM8s0"]],[41,"BigEyeBoyRoad",33554432,4,[-505],[[10,-503,[2,"68JGe3f+9FiZU5PT4eoy8i"],[5,1431,139],[0,0,1]],[49,0.23,0.75,false,-504,[2,"25SZg2zwdJj5mUvAkh9iYs"],5]],[7,"2bblZOMexB6ItDQeSyMSRi",1,0],[1,-715.5,-139,0]],[38,"view",33554432,216,[5],[[10,-506,[2,"1cLW9C7tRBnJPNR8kT5ywl"],[5,1431,139],[0,0,1]],[46,false,-507,[2,"ba/3fR15pPL5Nknx2JJLlI"]]],[7,"8a+InHgrNLQI4jzdfINYnb",1,0]],[41,"SmallRoad",33554432,4,[-510],[[10,-508,[2,"88k5Er8WRBFL89eEVssEl+"],[5,1431,139],[0,0,1]],[49,0.23,0.75,false,-509,[2,"da2EIWmHZDy5dFg89OUVY4"],9]],[7,"ffrJ7oWT1MfonPzi2p1OiM",1,0],[1,-715.5,-278,0]],[38,"view",33554432,218,[9],[[10,-511,[2,"f7xsLt2J5KkI/LC7IETqNR"],[5,1431,139],[0,0,1]],[46,false,-512,[2,"b7JkyjVUpFt5dkg33lYUPA"]]],[7,"19fBwdmfJFDoYvrs/M7/Jb",1,0]],[41,"CockroachRoad",33554432,4,[-515],[[10,-513,[2,"72Ng7ewaBJMLW2mOaw1a3T"],[5,1431,139],[0,0,1]],[49,0.23,0.75,false,-514,[2,"af8vU+6+dGDbKrxUBlSfqS"],10]],[7,"1b7FM/sBtKbZaE2Hc/zzej",1,0],[1,16.801,-278,0]],[38,"view",33554432,220,[10],[[10,-516,[2,"854Pw0K3tH4qCM9h8wr1no"],[5,1431,139],[0,0,1]],[46,false,-517,[2,"8cp+LiroxELLfab2voK4ee"]]],[7,"7aNENXvjtCrYjku3cNHDnP",1,0]],[112,"bg_cphroad2_2",33554432,15,[16],[[8,-518,[2,"f1PqseJABGB6p2/92MFiZL"],[5,783,46.39058823529412]],[16,0,-519,[2,"85+65FfuJODrUtxZXk3ipR"],215]],[7,"aekgnWgdFGSZ0/ORV4mYm+",1,0],[1,0,-477.669,0],[1,1.7,1.7,1.7]],[11,"icon_cphdown2",33554432,16,[[8,-520,[2,"ceOuolPHhClbiv6651md6T"],[5,27,26]],[15,-521,[2,"8cyH9lDcxICZUgISGTtKGJ"],213]],[7,"7dmdPdAWNEEIGb4XZ4eIcp",1,0],[1,0.1409999999999627,-0.3620000000000019,0]],[14,"bg_cellphone2",33554432,4,[[8,-522,[2,"24mGnCqwdA4ZAfDFM95R4n"],[5,1431,1080]],[16,0,-523,[2,"4fXSTS5L9IBJcPPsdF4VbU"],0]],[7,"17RCC34KxNd5qapZyKZZFQ",1,0]],[73,"bg_cphiattice",false,33554432,4,[[10,-524,[2,"54E80rEG5N6qYnxzhJnWJi"],[5,1190,830],[0,0,0.5]],[16,0,-525,[2,"85gvWk/1dMG4EqBSGtf0RL"],1]],[7,"6c928xj2ROCrRKk0fql6Bw",1,0],[1,-715.5,0,0]],[73,"bg_cphiattice-001",false,33554432,4,[[10,-526,[2,"96f1PC7P5PQaA4NLc8JwIT"],[5,1190,830],[0,0,0.5]],[16,0,-527,[2,"98UBK5yMdLOaWxcpU5uiqJ"],2]],[7,"51zu5lkhBL4JyYK4tSBTGx",1,0],[1,474.5,0,0]],[14,"bg_iattice2",33554432,7,[[10,-528,[2,"d4E74B+URIFauyOuCrUhCP"],[5,688,279],[0,0,1]],[16,0,-529,[2,"d9WFRkYEdGOJwO5puxTDBw"],3]],[7,"ebL4vYZ49P146ZAvNBc0Ez",1,0]],[11,"bg_iattice3",33554432,7,[[10,-530,[2,"5cZ9IL/EpMBauK+LrUVedz"],[5,688,279],[0,0,1]],[16,0,-531,[2,"d8Kf4B1EZG1Je+kFJO4OYD"],4]],[7,"1csMLA5/1JCIChH//bZKV4",1,0],[1,686.5,0,0]],[11,"bg_iattice4",33554432,7,[[10,-532,[2,"42flLMSjRGWoWBGVogBkDe"],[5,688,279],[0,0,1]],[16,0,-533,[2,"30RMZHUgdN2ZvCH8ZiJB8O"],5]],[7,"62jc81x0hJhIyicvFBdD4x",1,0],[1,1373,0,0]],[14,"contentSpriteRoad",33554432,12,[[10,-534,[2,"16t3uUujhNp5JDzNnqCDQs"],[5,0,0],[0,0,1]]],[7,"75kY79CQRLK6R/4bdtSFnw",1,0]],[14,"bg_iattice2",33554432,8,[[10,-535,[2,"7aKmmW3QBLyZAAiiT1qMBj"],[5,688,279],[0,0,1]],[16,0,-536,[2,"b9nL30TLJHgI96OMgLMI06"],6]],[7,"e2PPajbVVLYqO0LK1scoC0",1,0]],[11,"bg_iattice3",33554432,8,[[10,-537,[2,"f7tgkB+ONBNZW0oH8U+w5D"],[5,688,279],[0,0,1]],[16,0,-538,[2,"32kXCmSd1Kb5LCOCI35aaL"],7]],[7,"b7W64h2DtGwJGA5HLhsmV4",1,0],[1,686.5,0,0]],[11,"bg_iattice4",33554432,8,[[10,-539,[2,"48BGvzRVRDwIeeTvSVIP2R"],[5,688,279],[0,0,1]],[16,0,-540,[2,"82UGipQCJLX7pPIl4c1q18"],8]],[7,"8eGemqy0ROz6cbrJ/PDJSE",1,0],[1,1373,0,0]],[113,"contentSpriteBG",false,33554432,14,[2],[[10,-541,[2,"4ac/NunatKwbGx151+xpCC"],[5,0,0],[0,0,1]]],[7,"56Didd+qVIip6k62UA3CyN",1,0]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-542,[5,"e7X4OLmHNHBqlxraoVmddX",1,[[6,"RoadItem",["_name"],24],[0,["_lpos"],24,[1,23.52,-23.57,0]],[0,["_lrot"],24,[3,0,0,0,1]],[0,["_euler"],24,[1,0,0,0]]]],9]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-543,[5,"cbozdd4d9HF7Nl7WP1BrdT",1,[[6,"RoadItem-001",["_name"],25],[0,["_lpos"],25,[1,69.28999999999999,-23.57,0]],[0,["_lrot"],25,[3,0,0,0,1]],[0,["_euler"],25,[1,0,0,0]]]],10]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-544,[5,"07BpPrYxZNLLJ+BSfm6mum",1,[[6,"RoadItem-002",["_name"],26],[0,["_lpos"],26,[1,115.05999999999999,-23.57,0]],[0,["_lrot"],26,[3,0,0,0,1]],[0,["_euler"],26,[1,0,0,0]]]],11]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-545,[5,"2ezOkH5ghF1rTXJliYyVGB",1,[[6,"RoadItem-003",["_name"],27],[0,["_lpos"],27,[1,160.83,-23.57,0]],[0,["_lrot"],27,[3,0,0,0,1]],[0,["_euler"],27,[1,0,0,0]]]],12]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-546,[5,"dfWQNstxdF4J2ziB0Yt2Mi",1,[[6,"RoadItem-004",["_name"],28],[0,["_lpos"],28,[1,206.60000000000002,-23.57,0]],[0,["_lrot"],28,[3,0,0,0,1]],[0,["_euler"],28,[1,0,0,0]]]],13]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-547,[5,"4aMBvDRphBrbhwE7mUbEAB",1,[[6,"RoadItem-005",["_name"],29],[0,["_lpos"],29,[1,252.37000000000003,-23.57,0]],[0,["_lrot"],29,[3,0,0,0,1]],[0,["_euler"],29,[1,0,0,0]]]],14]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-548,[5,"e8gkpG7d5GqL8sYfKVyySp",1,[[6,"RoadItem-006",["_name"],30],[0,["_lpos"],30,[1,298.14,-23.57,0]],[0,["_lrot"],30,[3,0,0,0,1]],[0,["_euler"],30,[1,0,0,0]]]],15]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-549,[5,"b3B1c9fbdEd7z6GmrCr7B5",1,[[6,"RoadItem-007",["_name"],31],[0,["_lpos"],31,[1,343.90999999999997,-23.57,0]],[0,["_lrot"],31,[3,0,0,0,1]],[0,["_euler"],31,[1,0,0,0]]]],16]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-550,[5,"8abTiN73ZDY5umhr/u2A6P",1,[[6,"RoadItem-008",["_name"],32],[0,["_lpos"],32,[1,389.67999999999995,-23.57,0]],[0,["_lrot"],32,[3,0,0,0,1]],[0,["_euler"],32,[1,0,0,0]]]],17]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-551,[5,"b2DE4Qy5dLNKl/wge5/6Br",1,[[6,"RoadItem-009",["_name"],33],[0,["_lpos"],33,[1,435.44999999999993,-23.57,0]],[0,["_lrot"],33,[3,0,0,0,1]],[0,["_euler"],33,[1,0,0,0]]]],18]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-552,[5,"ccsbszpFpIALoM21m5gH3c",1,[[6,"RoadItem-010",["_name"],34],[0,["_lpos"],34,[1,481.2199999999999,-23.57,0]],[0,["_lrot"],34,[3,0,0,0,1]],[0,["_euler"],34,[1,0,0,0]]]],19]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-553,[5,"37BcPkqWBLyrue/HxqZxte",1,[[6,"RoadItem-011",["_name"],35],[0,["_lpos"],35,[1,526.9899999999999,-23.57,0]],[0,["_lrot"],35,[3,0,0,0,1]],[0,["_euler"],35,[1,0,0,0]]]],20]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-554,[5,"93zKa/AuhO44kM0ea5kfO0",1,[[6,"RoadItem-012",["_name"],36],[0,["_lpos"],36,[1,572.7599999999999,-23.57,0]],[0,["_lrot"],36,[3,0,0,0,1]],[0,["_euler"],36,[1,0,0,0]]]],21]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-555,[5,"53gE6vUexORImX//01Ory+",1,[[6,"RoadItem-013",["_name"],37],[0,["_lpos"],37,[1,618.5299999999999,-23.57,0]],[0,["_lrot"],37,[3,0,0,0,1]],[0,["_euler"],37,[1,0,0,0]]]],22]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-556,[5,"1fQ4dWuLZGy5wIdN7TgonX",1,[[6,"RoadItem-014",["_name"],38],[0,["_lpos"],38,[1,664.2999999999998,-23.57,0]],[0,["_lrot"],38,[3,0,0,0,1]],[0,["_euler"],38,[1,0,0,0]]]],23]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-557,[5,"1e8RL6a0dNNLF3Ig6pADOi",1,[[6,"RoadItem-015",["_name"],39],[0,["_lpos"],39,[1,710.0699999999998,-23.57,0]],[0,["_lrot"],39,[3,0,0,0,1]],[0,["_euler"],39,[1,0,0,0]]]],24]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-558,[5,"3deM5PxiZF3Zx73A+5hQVh",1,[[6,"RoadItem-016",["_name"],40],[0,["_lpos"],40,[1,755.8399999999998,-23.57,0]],[0,["_lrot"],40,[3,0,0,0,1]],[0,["_euler"],40,[1,0,0,0]]]],25]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-559,[5,"0142Zr0sxN9I8ZoBKWZTSa",1,[[6,"RoadItem-017",["_name"],41],[0,["_lpos"],41,[1,801.6099999999998,-23.57,0]],[0,["_lrot"],41,[3,0,0,0,1]],[0,["_euler"],41,[1,0,0,0]]]],26]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-560,[5,"a0IdD4DBhP8JCvdwiUXJ17",1,[[6,"RoadItem-018",["_name"],42],[0,["_lpos"],42,[1,847.3799999999998,-23.57,0]],[0,["_lrot"],42,[3,0,0,0,1]],[0,["_euler"],42,[1,0,0,0]]]],27]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-561,[5,"876G8CqcVNbpunMGgYD+FD",1,[[6,"RoadItem-019",["_name"],43],[0,["_lpos"],43,[1,893.1499999999997,-23.57,0]],[0,["_lrot"],43,[3,0,0,0,1]],[0,["_euler"],43,[1,0,0,0]]]],28]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-562,[5,"40VFKX/JJDq426M3ciCvcC",1,[[6,"RoadItem-020",["_name"],44],[0,["_lpos"],44,[1,938.9199999999997,-23.57,0]],[0,["_lrot"],44,[3,0,0,0,1]],[0,["_euler"],44,[1,0,0,0]]]],29]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-563,[5,"beLx2LR5dPaZ72lvwKcfT+",1,[[6,"RoadItem-021",["_name"],45],[0,["_lpos"],45,[1,984.6899999999997,-23.57,0]],[0,["_lrot"],45,[3,0,0,0,1]],[0,["_euler"],45,[1,0,0,0]]]],30]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-564,[5,"f1KtCMRBFEO7F+Nn0rK9SD",1,[[6,"RoadItem-022",["_name"],46],[0,["_lpos"],46,[1,1030.4599999999998,-23.57,0]],[0,["_lrot"],46,[3,0,0,0,1]],[0,["_euler"],46,[1,0,0,0]]]],31]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-565,[5,"b1bbOTH8RFKICJK46RDP63",1,[[6,"RoadItem-023",["_name"],47],[0,["_lpos"],47,[1,1076.2299999999998,-23.57,0]],[0,["_lrot"],47,[3,0,0,0,1]],[0,["_euler"],47,[1,0,0,0]]]],32]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-566,[5,"fd+i30g7BM7pncfYuiN8mN",1,[[6,"RoadItem-024",["_name"],48],[0,["_lpos"],48,[1,1121.9999999999998,-23.57,0]],[0,["_lrot"],48,[3,0,0,0,1]],[0,["_euler"],48,[1,0,0,0]]]],33]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-567,[5,"108myK+AZGArIlCHPw7aS5",1,[[6,"RoadItem-025",["_name"],49],[0,["_lpos"],49,[1,1167.7699999999998,-23.57,0]],[0,["_lrot"],49,[3,0,0,0,1]],[0,["_euler"],49,[1,0,0,0]]]],34]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-568,[5,"c3jj+cTrFFxIe8L7Caz5yE",1,[[6,"RoadItem-026",["_name"],50],[0,["_lpos"],50,[1,1213.5399999999997,-23.57,0]],[0,["_lrot"],50,[3,0,0,0,1]],[0,["_euler"],50,[1,0,0,0]]]],35]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-569,[5,"b8TCmc9WlDhoRgBEmWRgsj",1,[[6,"RoadItem-027",["_name"],51],[0,["_lpos"],51,[1,1259.3099999999997,-23.57,0]],[0,["_lrot"],51,[3,0,0,0,1]],[0,["_euler"],51,[1,0,0,0]]]],36]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-570,[5,"53dASTL/pL8pHOj6bqOSSJ",1,[[6,"RoadItem-028",["_name"],52],[0,["_lpos"],52,[1,1305.0799999999997,-23.57,0]],[0,["_lrot"],52,[3,0,0,0,1]],[0,["_euler"],52,[1,0,0,0]]]],37]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-571,[5,"89ZQv5VctKG7FGbf5WtGKe",1,[[6,"RoadItem-029",["_name"],53],[0,["_lpos"],53,[1,1350.8499999999997,-23.57,0]],[0,["_lrot"],53,[3,0,0,0,1]],[0,["_euler"],53,[1,0,0,0]]]],38]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-572,[5,"f0sNEZBdRB7YvetvMOzrjw",1,[[6,"RoadItem-030",["_name"],54],[0,["_lpos"],54,[1,1396.6199999999997,-23.57,0]],[0,["_lrot"],54,[3,0,0,0,1]],[0,["_euler"],54,[1,0,0,0]]]],39]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-573,[5,"72N/3A9flMc4xt5nY6MvQo",1,[[6,"RoadItem-031",["_name"],55],[0,["_lpos"],55,[1,23.52,-69.86999999999999,0]],[0,["_lrot"],55,[3,0,0,0,1]],[0,["_euler"],55,[1,0,0,0]]]],40]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-574,[5,"4dAj28TitDtbng+74RHIIa",1,[[6,"RoadItem-032",["_name"],56],[0,["_lpos"],56,[1,69.28999999999999,-69.86999999999999,0]],[0,["_lrot"],56,[3,0,0,0,1]],[0,["_euler"],56,[1,0,0,0]]]],41]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-575,[5,"e1NDd9ZvJPALScymjRImf5",1,[[6,"RoadItem-033",["_name"],57],[0,["_lpos"],57,[1,115.05999999999999,-69.86999999999999,0]],[0,["_lrot"],57,[3,0,0,0,1]],[0,["_euler"],57,[1,0,0,0]]]],42]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-576,[5,"cfAdFx1fhIkr7i5VFxPjFo",1,[[6,"RoadItem-034",["_name"],58],[0,["_lpos"],58,[1,160.83,-69.86999999999999,0]],[0,["_lrot"],58,[3,0,0,0,1]],[0,["_euler"],58,[1,0,0,0]]]],43]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-577,[5,"04ae+g0kdBxohMS4Btr8Er",1,[[6,"RoadItem-035",["_name"],59],[0,["_lpos"],59,[1,206.60000000000002,-69.86999999999999,0]],[0,["_lrot"],59,[3,0,0,0,1]],[0,["_euler"],59,[1,0,0,0]]]],44]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-578,[5,"73mWgkGz1I8a5IYfCKXFJ+",1,[[6,"RoadItem-036",["_name"],60],[0,["_lpos"],60,[1,252.37000000000003,-69.86999999999999,0]],[0,["_lrot"],60,[3,0,0,0,1]],[0,["_euler"],60,[1,0,0,0]]]],45]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-579,[5,"d8HygWNbdADJw20uoJVBOx",1,[[6,"RoadItem-037",["_name"],61],[0,["_lpos"],61,[1,298.14,-69.86999999999999,0]],[0,["_lrot"],61,[3,0,0,0,1]],[0,["_euler"],61,[1,0,0,0]]]],46]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-580,[5,"e54L0BXz5ALYgc/jpcBLOT",1,[[6,"RoadItem-038",["_name"],62],[0,["_lpos"],62,[1,343.90999999999997,-69.86999999999999,0]],[0,["_lrot"],62,[3,0,0,0,1]],[0,["_euler"],62,[1,0,0,0]]]],47]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-581,[5,"06CesewZJJ3LnVsa1CvDah",1,[[6,"RoadItem-039",["_name"],63],[0,["_lpos"],63,[1,389.67999999999995,-69.86999999999999,0]],[0,["_lrot"],63,[3,0,0,0,1]],[0,["_euler"],63,[1,0,0,0]]]],48]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-582,[5,"ffCwrypqpN+IziHx4yUZEp",1,[[6,"RoadItem-040",["_name"],64],[0,["_lpos"],64,[1,435.44999999999993,-69.86999999999999,0]],[0,["_lrot"],64,[3,0,0,0,1]],[0,["_euler"],64,[1,0,0,0]]]],49]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-583,[5,"8dei34CRhJe5bGMoQVeJHW",1,[[6,"RoadItem-041",["_name"],65],[0,["_lpos"],65,[1,481.2199999999999,-69.86999999999999,0]],[0,["_lrot"],65,[3,0,0,0,1]],[0,["_euler"],65,[1,0,0,0]]]],50]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-584,[5,"d9Jo50DvZLNJ5lcZIasvQr",1,[[6,"RoadItem-042",["_name"],66],[0,["_lpos"],66,[1,526.9899999999999,-69.86999999999999,0]],[0,["_lrot"],66,[3,0,0,0,1]],[0,["_euler"],66,[1,0,0,0]]]],51]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-585,[5,"4bZxctAdhJGKzDOj43+5mI",1,[[6,"RoadItem-043",["_name"],67],[0,["_lpos"],67,[1,572.7599999999999,-69.86999999999999,0]],[0,["_lrot"],67,[3,0,0,0,1]],[0,["_euler"],67,[1,0,0,0]]]],52]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-586,[5,"2eQO7DdfxPmYLgzmPG3bMs",1,[[6,"RoadItem-044",["_name"],68],[0,["_lpos"],68,[1,618.5299999999999,-69.86999999999999,0]],[0,["_lrot"],68,[3,0,0,0,1]],[0,["_euler"],68,[1,0,0,0]]]],53]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-587,[5,"c1RGl7pNtC95ZIsvLULRJe",1,[[6,"RoadItem-045",["_name"],69],[0,["_lpos"],69,[1,664.2999999999998,-69.86999999999999,0]],[0,["_lrot"],69,[3,0,0,0,1]],[0,["_euler"],69,[1,0,0,0]]]],54]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-588,[5,"1epkBJE2FEiJE09pkGCMLD",1,[[6,"RoadItem-046",["_name"],70],[0,["_lpos"],70,[1,710.0699999999998,-69.86999999999999,0]],[0,["_lrot"],70,[3,0,0,0,1]],[0,["_euler"],70,[1,0,0,0]]]],55]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-589,[5,"c9EFi7MqBHyIOOPQ9iVoVl",1,[[6,"RoadItem-047",["_name"],71],[0,["_lpos"],71,[1,755.8399999999998,-69.86999999999999,0]],[0,["_lrot"],71,[3,0,0,0,1]],[0,["_euler"],71,[1,0,0,0]]]],56]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-590,[5,"67OYoWFPFJ27eUojwHZdwr",1,[[6,"RoadItem-048",["_name"],72],[0,["_lpos"],72,[1,801.6099999999998,-69.86999999999999,0]],[0,["_lrot"],72,[3,0,0,0,1]],[0,["_euler"],72,[1,0,0,0]]]],57]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-591,[5,"59nVAstoRC9LkAuBVWUxJD",1,[[6,"RoadItem-049",["_name"],73],[0,["_lpos"],73,[1,847.3799999999998,-69.86999999999999,0]],[0,["_lrot"],73,[3,0,0,0,1]],[0,["_euler"],73,[1,0,0,0]]]],58]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-592,[5,"ffp368v/RO2pRgOozih17C",1,[[6,"RoadItem-050",["_name"],74],[0,["_lpos"],74,[1,893.1499999999997,-69.86999999999999,0]],[0,["_lrot"],74,[3,0,0,0,1]],[0,["_euler"],74,[1,0,0,0]]]],59]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-593,[5,"e37X3OsiNFVpTtCqLCPTwv",1,[[6,"RoadItem-051",["_name"],75],[0,["_lpos"],75,[1,938.9199999999997,-69.86999999999999,0]],[0,["_lrot"],75,[3,0,0,0,1]],[0,["_euler"],75,[1,0,0,0]]]],60]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-594,[5,"535Pc7CxZC/IjsZ9KTVjvF",1,[[6,"RoadItem-052",["_name"],76],[0,["_lpos"],76,[1,984.6899999999997,-69.86999999999999,0]],[0,["_lrot"],76,[3,0,0,0,1]],[0,["_euler"],76,[1,0,0,0]]]],61]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-595,[5,"00VgRpeWxJVbNVVZzSuRwZ",1,[[6,"RoadItem-053",["_name"],77],[0,["_lpos"],77,[1,1030.4599999999998,-69.86999999999999,0]],[0,["_lrot"],77,[3,0,0,0,1]],[0,["_euler"],77,[1,0,0,0]]]],62]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-596,[5,"a0aeJR93dCSKOP86zmlHXY",1,[[6,"RoadItem-054",["_name"],78],[0,["_lpos"],78,[1,1076.2299999999998,-69.86999999999999,0]],[0,["_lrot"],78,[3,0,0,0,1]],[0,["_euler"],78,[1,0,0,0]]]],63]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-597,[5,"ebDWzWb6FOu4qLeMznRbLz",1,[[6,"RoadItem-055",["_name"],79],[0,["_lpos"],79,[1,1121.9999999999998,-69.86999999999999,0]],[0,["_lrot"],79,[3,0,0,0,1]],[0,["_euler"],79,[1,0,0,0]]]],64]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-598,[5,"efPPie35FPLKcUMRjlpWv+",1,[[6,"RoadItem-056",["_name"],80],[0,["_lpos"],80,[1,1167.7699999999998,-69.86999999999999,0]],[0,["_lrot"],80,[3,0,0,0,1]],[0,["_euler"],80,[1,0,0,0]]]],65]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-599,[5,"f5G+cO9a5Jx4nE61CGBBbw",1,[[6,"RoadItem-057",["_name"],81],[0,["_lpos"],81,[1,1213.5399999999997,-69.86999999999999,0]],[0,["_lrot"],81,[3,0,0,0,1]],[0,["_euler"],81,[1,0,0,0]]]],66]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-600,[5,"96jkO5315Mir0EeJoFcFvl",1,[[6,"RoadItem-058",["_name"],82],[0,["_lpos"],82,[1,1259.3099999999997,-69.86999999999999,0]],[0,["_lrot"],82,[3,0,0,0,1]],[0,["_euler"],82,[1,0,0,0]]]],67]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-601,[5,"abSGc7SzVAKZSZHHJQcGXo",1,[[6,"RoadItem-059",["_name"],83],[0,["_lpos"],83,[1,1305.0799999999997,-69.86999999999999,0]],[0,["_lrot"],83,[3,0,0,0,1]],[0,["_euler"],83,[1,0,0,0]]]],68]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-602,[5,"acdwAMYJ9OvbtHLwtwSv9I",1,[[6,"RoadItem-060",["_name"],84],[0,["_lpos"],84,[1,1350.8499999999997,-69.86999999999999,0]],[0,["_lrot"],84,[3,0,0,0,1]],[0,["_euler"],84,[1,0,0,0]]]],69]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-603,[5,"69tz5RC8pD+58ro7tJcLIc",1,[[6,"RoadItem-061",["_name"],85],[0,["_lpos"],85,[1,1396.6199999999997,-69.86999999999999,0]],[0,["_lrot"],85,[3,0,0,0,1]],[0,["_euler"],85,[1,0,0,0]]]],70]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-604,[5,"2bp/d8KqBAU4UEONH+LvtL",1,[[6,"RoadItem-062",["_name"],86],[0,["_lpos"],86,[1,23.52,-116.16999999999999,0]],[0,["_lrot"],86,[3,0,0,0,1]],[0,["_euler"],86,[1,0,0,0]]]],71]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-605,[5,"86jeiYnFNC/bFCVw3xaDIT",1,[[6,"RoadItem-063",["_name"],87],[0,["_lpos"],87,[1,69.28999999999999,-116.16999999999999,0]],[0,["_lrot"],87,[3,0,0,0,1]],[0,["_euler"],87,[1,0,0,0]]]],72]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-606,[5,"8e5VUFigBE9akuzds/ndRu",1,[[6,"RoadItem-064",["_name"],88],[0,["_lpos"],88,[1,115.05999999999999,-116.16999999999999,0]],[0,["_lrot"],88,[3,0,0,0,1]],[0,["_euler"],88,[1,0,0,0]]]],73]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-607,[5,"41FxDBb1lFObBeX58kEl/1",1,[[6,"RoadItem-065",["_name"],89],[0,["_lpos"],89,[1,160.83,-116.16999999999999,0]],[0,["_lrot"],89,[3,0,0,0,1]],[0,["_euler"],89,[1,0,0,0]]]],74]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-608,[5,"b8DmUgBR9OGJ7uGY9DpqaY",1,[[6,"RoadItem-066",["_name"],90],[0,["_lpos"],90,[1,206.60000000000002,-116.16999999999999,0]],[0,["_lrot"],90,[3,0,0,0,1]],[0,["_euler"],90,[1,0,0,0]]]],75]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-609,[5,"59kj/bbMBFF4VAhaqZycAL",1,[[6,"RoadItem-067",["_name"],91],[0,["_lpos"],91,[1,252.37000000000003,-116.16999999999999,0]],[0,["_lrot"],91,[3,0,0,0,1]],[0,["_euler"],91,[1,0,0,0]]]],76]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-610,[5,"0bj/3B1YxJn7a4HkUihNjx",1,[[6,"RoadItem-068",["_name"],92],[0,["_lpos"],92,[1,298.14,-116.16999999999999,0]],[0,["_lrot"],92,[3,0,0,0,1]],[0,["_euler"],92,[1,0,0,0]]]],77]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-611,[5,"11EEy/R4hAW5jHORnC1yHM",1,[[6,"RoadItem-069",["_name"],93],[0,["_lpos"],93,[1,343.90999999999997,-116.16999999999999,0]],[0,["_lrot"],93,[3,0,0,0,1]],[0,["_euler"],93,[1,0,0,0]]]],78]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-612,[5,"3aWnE/OuNIKJ4HtWHspp/d",1,[[6,"RoadItem-070",["_name"],94],[0,["_lpos"],94,[1,389.67999999999995,-116.16999999999999,0]],[0,["_lrot"],94,[3,0,0,0,1]],[0,["_euler"],94,[1,0,0,0]]]],79]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-613,[5,"a0rf4q5qZNMawYh1TBQeVC",1,[[6,"RoadItem-071",["_name"],95],[0,["_lpos"],95,[1,435.44999999999993,-116.16999999999999,0]],[0,["_lrot"],95,[3,0,0,0,1]],[0,["_euler"],95,[1,0,0,0]]]],80]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-614,[5,"31KGMh24VEo40T1EV/AiQq",1,[[6,"RoadItem-072",["_name"],96],[0,["_lpos"],96,[1,481.2199999999999,-116.16999999999999,0]],[0,["_lrot"],96,[3,0,0,0,1]],[0,["_euler"],96,[1,0,0,0]]]],81]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-615,[5,"9crjXs01pNBbBleiGJD39M",1,[[6,"RoadItem-073",["_name"],97],[0,["_lpos"],97,[1,526.9899999999999,-116.16999999999999,0]],[0,["_lrot"],97,[3,0,0,0,1]],[0,["_euler"],97,[1,0,0,0]]]],82]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-616,[5,"8f1Q83ePNJm5gnuL6/GI3n",1,[[6,"RoadItem-074",["_name"],98],[0,["_lpos"],98,[1,572.7599999999999,-116.16999999999999,0]],[0,["_lrot"],98,[3,0,0,0,1]],[0,["_euler"],98,[1,0,0,0]]]],83]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-617,[5,"87Z4zY6eZGLIVnsqLPqqIW",1,[[6,"RoadItem-075",["_name"],99],[0,["_lpos"],99,[1,618.5299999999999,-116.16999999999999,0]],[0,["_lrot"],99,[3,0,0,0,1]],[0,["_euler"],99,[1,0,0,0]]]],84]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-618,[5,"74TCYCc4tGa4q2pDvL6VGf",1,[[6,"RoadItem-076",["_name"],100],[0,["_lpos"],100,[1,664.2999999999998,-116.16999999999999,0]],[0,["_lrot"],100,[3,0,0,0,1]],[0,["_euler"],100,[1,0,0,0]]]],85]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-619,[5,"7e7Hs4QuRFYpke+80FIWbb",1,[[6,"RoadItem-077",["_name"],101],[0,["_lpos"],101,[1,710.0699999999998,-116.16999999999999,0]],[0,["_lrot"],101,[3,0,0,0,1]],[0,["_euler"],101,[1,0,0,0]]]],86]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-620,[5,"faLCilCG5HF598W93ubw51",1,[[6,"RoadItem-078",["_name"],102],[0,["_lpos"],102,[1,755.8399999999998,-116.16999999999999,0]],[0,["_lrot"],102,[3,0,0,0,1]],[0,["_euler"],102,[1,0,0,0]]]],87]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-621,[5,"03GubR45hDw54c7fhOGpVl",1,[[6,"RoadItem-079",["_name"],103],[0,["_lpos"],103,[1,801.6099999999998,-116.16999999999999,0]],[0,["_lrot"],103,[3,0,0,0,1]],[0,["_euler"],103,[1,0,0,0]]]],88]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-622,[5,"34K5g4jrdPdYN1Zg2R5lA+",1,[[6,"RoadItem-080",["_name"],104],[0,["_lpos"],104,[1,847.3799999999998,-116.16999999999999,0]],[0,["_lrot"],104,[3,0,0,0,1]],[0,["_euler"],104,[1,0,0,0]]]],89]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-623,[5,"983MMhVVFLGKE0FylnwScX",1,[[6,"RoadItem-081",["_name"],105],[0,["_lpos"],105,[1,893.1499999999997,-116.16999999999999,0]],[0,["_lrot"],105,[3,0,0,0,1]],[0,["_euler"],105,[1,0,0,0]]]],90]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-624,[5,"90AQ6SWZNKWoWALBwVZxCe",1,[[6,"RoadItem-082",["_name"],106],[0,["_lpos"],106,[1,938.9199999999997,-116.16999999999999,0]],[0,["_lrot"],106,[3,0,0,0,1]],[0,["_euler"],106,[1,0,0,0]]]],91]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-625,[5,"3dBz0KUUFBuoKaOFgTRBKT",1,[[6,"RoadItem-083",["_name"],107],[0,["_lpos"],107,[1,984.6899999999997,-116.16999999999999,0]],[0,["_lrot"],107,[3,0,0,0,1]],[0,["_euler"],107,[1,0,0,0]]]],92]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-626,[5,"b9jmQCjVRBfproRpuzRT6B",1,[[6,"RoadItem-084",["_name"],108],[0,["_lpos"],108,[1,1030.4599999999998,-116.16999999999999,0]],[0,["_lrot"],108,[3,0,0,0,1]],[0,["_euler"],108,[1,0,0,0]]]],93]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-627,[5,"59blceVhJOKI2uy3srssST",1,[[6,"RoadItem-085",["_name"],109],[0,["_lpos"],109,[1,1076.2299999999998,-116.16999999999999,0]],[0,["_lrot"],109,[3,0,0,0,1]],[0,["_euler"],109,[1,0,0,0]]]],94]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-628,[5,"bb0BhmZABP9pVVi36gh4kf",1,[[6,"RoadItem-086",["_name"],110],[0,["_lpos"],110,[1,1121.9999999999998,-116.16999999999999,0]],[0,["_lrot"],110,[3,0,0,0,1]],[0,["_euler"],110,[1,0,0,0]]]],95]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-629,[5,"4dqsAmfDBAuZao9TNB+JLY",1,[[6,"RoadItem-087",["_name"],111],[0,["_lpos"],111,[1,1167.7699999999998,-116.16999999999999,0]],[0,["_lrot"],111,[3,0,0,0,1]],[0,["_euler"],111,[1,0,0,0]]]],96]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-630,[5,"17nzt8aIdNdrsBU22ZxLqS",1,[[6,"RoadItem-088",["_name"],112],[0,["_lpos"],112,[1,1213.5399999999997,-116.16999999999999,0]],[0,["_lrot"],112,[3,0,0,0,1]],[0,["_euler"],112,[1,0,0,0]]]],97]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-631,[5,"88Bz99wfVHgYrAaJzIDriJ",1,[[6,"RoadItem-089",["_name"],113],[0,["_lpos"],113,[1,1259.3099999999997,-116.16999999999999,0]],[0,["_lrot"],113,[3,0,0,0,1]],[0,["_euler"],113,[1,0,0,0]]]],98]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-632,[5,"83DmPF4BRKpZR44jU8b0Fj",1,[[6,"RoadItem-090",["_name"],114],[0,["_lpos"],114,[1,1305.0799999999997,-116.16999999999999,0]],[0,["_lrot"],114,[3,0,0,0,1]],[0,["_euler"],114,[1,0,0,0]]]],99]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-633,[5,"e4+VsPXg9F/4nLxpmHerxl",1,[[6,"RoadItem-091",["_name"],115],[0,["_lpos"],115,[1,1350.8499999999997,-116.16999999999999,0]],[0,["_lrot"],115,[3,0,0,0,1]],[0,["_euler"],115,[1,0,0,0]]]],100]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-634,[5,"11d5E0U3xCUL68wKrdgxt5",1,[[6,"RoadItem-092",["_name"],116],[0,["_lpos"],116,[1,1396.6199999999997,-116.16999999999999,0]],[0,["_lrot"],116,[3,0,0,0,1]],[0,["_euler"],116,[1,0,0,0]]]],101]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-635,[5,"9bA7jOunhF24jjbpE0zxV/",1,[[6,"RoadItem-093",["_name"],117],[0,["_lpos"],117,[1,23.52,-162.46999999999997,0]],[0,["_lrot"],117,[3,0,0,0,1]],[0,["_euler"],117,[1,0,0,0]]]],102]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-636,[5,"9aIxOGjwFCzIN2V5VuyA5g",1,[[6,"RoadItem-094",["_name"],118],[0,["_lpos"],118,[1,69.28999999999999,-162.46999999999997,0]],[0,["_lrot"],118,[3,0,0,0,1]],[0,["_euler"],118,[1,0,0,0]]]],103]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-637,[5,"d9pe5tq69Cx6mvX3/7fccK",1,[[6,"RoadItem-095",["_name"],119],[0,["_lpos"],119,[1,115.05999999999999,-162.46999999999997,0]],[0,["_lrot"],119,[3,0,0,0,1]],[0,["_euler"],119,[1,0,0,0]]]],104]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-638,[5,"d2u25pGjZBBLJ6ppczzwMi",1,[[6,"RoadItem-096",["_name"],120],[0,["_lpos"],120,[1,160.83,-162.46999999999997,0]],[0,["_lrot"],120,[3,0,0,0,1]],[0,["_euler"],120,[1,0,0,0]]]],105]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-639,[5,"08cs7h8oxIOoL/1HFcycCJ",1,[[6,"RoadItem-097",["_name"],121],[0,["_lpos"],121,[1,206.60000000000002,-162.46999999999997,0]],[0,["_lrot"],121,[3,0,0,0,1]],[0,["_euler"],121,[1,0,0,0]]]],106]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-640,[5,"82aI8NU31Dw7JNUH9Tn4PX",1,[[6,"RoadItem-098",["_name"],122],[0,["_lpos"],122,[1,252.37000000000003,-162.46999999999997,0]],[0,["_lrot"],122,[3,0,0,0,1]],[0,["_euler"],122,[1,0,0,0]]]],107]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-641,[5,"12VVfKoSxH4YnQfDxMvDgw",1,[[6,"RoadItem-099",["_name"],123],[0,["_lpos"],123,[1,298.14,-162.46999999999997,0]],[0,["_lrot"],123,[3,0,0,0,1]],[0,["_euler"],123,[1,0,0,0]]]],108]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-642,[5,"eeeE04EAFLIJGLP87hMXr5",1,[[6,"RoadItem-100",["_name"],124],[0,["_lpos"],124,[1,343.90999999999997,-162.46999999999997,0]],[0,["_lrot"],124,[3,0,0,0,1]],[0,["_euler"],124,[1,0,0,0]]]],109]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-643,[5,"56YEJHVO9OsLvym7kjCDNj",1,[[6,"RoadItem-101",["_name"],125],[0,["_lpos"],125,[1,389.67999999999995,-162.46999999999997,0]],[0,["_lrot"],125,[3,0,0,0,1]],[0,["_euler"],125,[1,0,0,0]]]],110]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-644,[5,"06SUHrA0JJZajgEqFXDWH2",1,[[6,"RoadItem-102",["_name"],126],[0,["_lpos"],126,[1,435.44999999999993,-162.46999999999997,0]],[0,["_lrot"],126,[3,0,0,0,1]],[0,["_euler"],126,[1,0,0,0]]]],111]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-645,[5,"a8sFKZadhBTK1YcwTt+Qr7",1,[[6,"RoadItem-103",["_name"],127],[0,["_lpos"],127,[1,481.2199999999999,-162.46999999999997,0]],[0,["_lrot"],127,[3,0,0,0,1]],[0,["_euler"],127,[1,0,0,0]]]],112]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-646,[5,"69NjmcP9BMTbpQRv8XOOmv",1,[[6,"RoadItem-104",["_name"],128],[0,["_lpos"],128,[1,526.9899999999999,-162.46999999999997,0]],[0,["_lrot"],128,[3,0,0,0,1]],[0,["_euler"],128,[1,0,0,0]]]],113]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-647,[5,"1d3Nc+D/ZKKoNZs1RuGP8W",1,[[6,"RoadItem-105",["_name"],129],[0,["_lpos"],129,[1,572.7599999999999,-162.46999999999997,0]],[0,["_lrot"],129,[3,0,0,0,1]],[0,["_euler"],129,[1,0,0,0]]]],114]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-648,[5,"02I/6r1ulCC4PyguH+9eFd",1,[[6,"RoadItem-106",["_name"],130],[0,["_lpos"],130,[1,618.5299999999999,-162.46999999999997,0]],[0,["_lrot"],130,[3,0,0,0,1]],[0,["_euler"],130,[1,0,0,0]]]],115]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-649,[5,"ab92/13VtHfqtrvCKxqSA7",1,[[6,"RoadItem-107",["_name"],131],[0,["_lpos"],131,[1,664.2999999999998,-162.46999999999997,0]],[0,["_lrot"],131,[3,0,0,0,1]],[0,["_euler"],131,[1,0,0,0]]]],116]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-650,[5,"c1iZl5OQZJB6YxaviH/TrO",1,[[6,"RoadItem-108",["_name"],132],[0,["_lpos"],132,[1,710.0699999999998,-162.46999999999997,0]],[0,["_lrot"],132,[3,0,0,0,1]],[0,["_euler"],132,[1,0,0,0]]]],117]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-651,[5,"17wWx2WjVNMZoLP8Z6G4DZ",1,[[6,"RoadItem-109",["_name"],133],[0,["_lpos"],133,[1,755.8399999999998,-162.46999999999997,0]],[0,["_lrot"],133,[3,0,0,0,1]],[0,["_euler"],133,[1,0,0,0]]]],118]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-652,[5,"d2+PGEJqFMtJrPrx/Rpta7",1,[[6,"RoadItem-110",["_name"],134],[0,["_lpos"],134,[1,801.6099999999998,-162.46999999999997,0]],[0,["_lrot"],134,[3,0,0,0,1]],[0,["_euler"],134,[1,0,0,0]]]],119]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-653,[5,"74/bWthopDA4lak5ZTRTop",1,[[6,"RoadItem-111",["_name"],135],[0,["_lpos"],135,[1,847.3799999999998,-162.46999999999997,0]],[0,["_lrot"],135,[3,0,0,0,1]],[0,["_euler"],135,[1,0,0,0]]]],120]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-654,[5,"9eNaMK7OlF2Y3UlA8YFfAF",1,[[6,"RoadItem-112",["_name"],136],[0,["_lpos"],136,[1,893.1499999999997,-162.46999999999997,0]],[0,["_lrot"],136,[3,0,0,0,1]],[0,["_euler"],136,[1,0,0,0]]]],121]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-655,[5,"e2wcYiVchPdaMXEPdOtgwu",1,[[6,"RoadItem-113",["_name"],137],[0,["_lpos"],137,[1,938.9199999999997,-162.46999999999997,0]],[0,["_lrot"],137,[3,0,0,0,1]],[0,["_euler"],137,[1,0,0,0]]]],122]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-656,[5,"19t6LNn4hM2Jern72a+7ff",1,[[6,"RoadItem-114",["_name"],138],[0,["_lpos"],138,[1,984.6899999999997,-162.46999999999997,0]],[0,["_lrot"],138,[3,0,0,0,1]],[0,["_euler"],138,[1,0,0,0]]]],123]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-657,[5,"02wRTS5F5MP584RztqqnTh",1,[[6,"RoadItem-115",["_name"],139],[0,["_lpos"],139,[1,1030.4599999999998,-162.46999999999997,0]],[0,["_lrot"],139,[3,0,0,0,1]],[0,["_euler"],139,[1,0,0,0]]]],124]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-658,[5,"2dIK05acVDUJIxXWn1Fi28",1,[[6,"RoadItem-116",["_name"],140],[0,["_lpos"],140,[1,1076.2299999999998,-162.46999999999997,0]],[0,["_lrot"],140,[3,0,0,0,1]],[0,["_euler"],140,[1,0,0,0]]]],125]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-659,[5,"0buU611F5JMLdklPqet11S",1,[[6,"RoadItem-117",["_name"],141],[0,["_lpos"],141,[1,1121.9999999999998,-162.46999999999997,0]],[0,["_lrot"],141,[3,0,0,0,1]],[0,["_euler"],141,[1,0,0,0]]]],126]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-660,[5,"73+SlgEy5KfpxbjTcaq4D2",1,[[6,"RoadItem-118",["_name"],142],[0,["_lpos"],142,[1,1167.7699999999998,-162.46999999999997,0]],[0,["_lrot"],142,[3,0,0,0,1]],[0,["_euler"],142,[1,0,0,0]]]],127]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-661,[5,"e8a6NYHoVFKJ+R0GoOKL3U",1,[[6,"RoadItem-119",["_name"],143],[0,["_lpos"],143,[1,1213.5399999999997,-162.46999999999997,0]],[0,["_lrot"],143,[3,0,0,0,1]],[0,["_euler"],143,[1,0,0,0]]]],128]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-662,[5,"a9YWtmn1BMh4EfXJVhgGN6",1,[[6,"RoadItem-120",["_name"],144],[0,["_lpos"],144,[1,1259.3099999999997,-162.46999999999997,0]],[0,["_lrot"],144,[3,0,0,0,1]],[0,["_euler"],144,[1,0,0,0]]]],129]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-663,[5,"79w9I7IAVOG5jhUsLFHD/S",1,[[6,"RoadItem-121",["_name"],145],[0,["_lpos"],145,[1,1305.0799999999997,-162.46999999999997,0]],[0,["_lrot"],145,[3,0,0,0,1]],[0,["_euler"],145,[1,0,0,0]]]],130]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-664,[5,"61XWX68BRO/pA+lB1TAIoX",1,[[6,"RoadItem-122",["_name"],146],[0,["_lpos"],146,[1,1350.8499999999997,-162.46999999999997,0]],[0,["_lrot"],146,[3,0,0,0,1]],[0,["_euler"],146,[1,0,0,0]]]],131]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-665,[5,"55IqHHKthCMZ8oshogCk2e",1,[[6,"RoadItem-123",["_name"],147],[0,["_lpos"],147,[1,1396.6199999999997,-162.46999999999997,0]],[0,["_lrot"],147,[3,0,0,0,1]],[0,["_euler"],147,[1,0,0,0]]]],132]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-666,[5,"1alzb6npBKxbBrbmf8ZV7s",1,[[6,"RoadItem-124",["_name"],148],[0,["_lpos"],148,[1,23.52,-208.76999999999998,0]],[0,["_lrot"],148,[3,0,0,0,1]],[0,["_euler"],148,[1,0,0,0]]]],133]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-667,[5,"ddfh5SDoRG1JnP1M2mZKV5",1,[[6,"RoadItem-125",["_name"],149],[0,["_lpos"],149,[1,69.28999999999999,-208.76999999999998,0]],[0,["_lrot"],149,[3,0,0,0,1]],[0,["_euler"],149,[1,0,0,0]]]],134]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-668,[5,"96RwoC+WtCTqulRmdtrggP",1,[[6,"RoadItem-126",["_name"],150],[0,["_lpos"],150,[1,115.05999999999999,-208.76999999999998,0]],[0,["_lrot"],150,[3,0,0,0,1]],[0,["_euler"],150,[1,0,0,0]]]],135]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-669,[5,"1bCAuSUlVGI7LggHCkl5c2",1,[[6,"RoadItem-127",["_name"],151],[0,["_lpos"],151,[1,160.83,-208.76999999999998,0]],[0,["_lrot"],151,[3,0,0,0,1]],[0,["_euler"],151,[1,0,0,0]]]],136]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-670,[5,"34hmzA2zdMy7n/4415AVHO",1,[[6,"RoadItem-128",["_name"],152],[0,["_lpos"],152,[1,206.60000000000002,-208.76999999999998,0]],[0,["_lrot"],152,[3,0,0,0,1]],[0,["_euler"],152,[1,0,0,0]]]],137]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-671,[5,"2aV9x2uktL5472i3FDECbT",1,[[6,"RoadItem-129",["_name"],153],[0,["_lpos"],153,[1,252.37000000000003,-208.76999999999998,0]],[0,["_lrot"],153,[3,0,0,0,1]],[0,["_euler"],153,[1,0,0,0]]]],138]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-672,[5,"a5CWyly19PhrQjilSMj7ri",1,[[6,"RoadItem-130",["_name"],154],[0,["_lpos"],154,[1,298.14,-208.76999999999998,0]],[0,["_lrot"],154,[3,0,0,0,1]],[0,["_euler"],154,[1,0,0,0]]]],139]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-673,[5,"00DB9NS7xCJLVAltgtYabN",1,[[6,"RoadItem-131",["_name"],155],[0,["_lpos"],155,[1,343.90999999999997,-208.76999999999998,0]],[0,["_lrot"],155,[3,0,0,0,1]],[0,["_euler"],155,[1,0,0,0]]]],140]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-674,[5,"57bF1B2SBOip1wnGaS/Cuu",1,[[6,"RoadItem-132",["_name"],156],[0,["_lpos"],156,[1,389.67999999999995,-208.76999999999998,0]],[0,["_lrot"],156,[3,0,0,0,1]],[0,["_euler"],156,[1,0,0,0]]]],141]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-675,[5,"ef1Y6CBVxFXKA3peJKnM+i",1,[[6,"RoadItem-133",["_name"],157],[0,["_lpos"],157,[1,435.44999999999993,-208.76999999999998,0]],[0,["_lrot"],157,[3,0,0,0,1]],[0,["_euler"],157,[1,0,0,0]]]],142]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-676,[5,"60/7oQyxZC+Y/0gXDdC93K",1,[[6,"RoadItem-134",["_name"],158],[0,["_lpos"],158,[1,481.2199999999999,-208.76999999999998,0]],[0,["_lrot"],158,[3,0,0,0,1]],[0,["_euler"],158,[1,0,0,0]]]],143]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-677,[5,"91LUi3pshLTJZfejd8Pf4l",1,[[6,"RoadItem-135",["_name"],159],[0,["_lpos"],159,[1,526.9899999999999,-208.76999999999998,0]],[0,["_lrot"],159,[3,0,0,0,1]],[0,["_euler"],159,[1,0,0,0]]]],144]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-678,[5,"c2RdYGqBJGEbapp1yzWpC4",1,[[6,"RoadItem-136",["_name"],160],[0,["_lpos"],160,[1,572.7599999999999,-208.76999999999998,0]],[0,["_lrot"],160,[3,0,0,0,1]],[0,["_euler"],160,[1,0,0,0]]]],145]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-679,[5,"d0fRGLI5xHVYlcoAblKnq3",1,[[6,"RoadItem-137",["_name"],161],[0,["_lpos"],161,[1,618.5299999999999,-208.76999999999998,0]],[0,["_lrot"],161,[3,0,0,0,1]],[0,["_euler"],161,[1,0,0,0]]]],146]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-680,[5,"b5GYdTAURC76DW3wt/rH05",1,[[6,"RoadItem-138",["_name"],162],[0,["_lpos"],162,[1,664.2999999999998,-208.76999999999998,0]],[0,["_lrot"],162,[3,0,0,0,1]],[0,["_euler"],162,[1,0,0,0]]]],147]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-681,[5,"07CLY9PYVOarEzBWs1IEgF",1,[[6,"RoadItem-139",["_name"],163],[0,["_lpos"],163,[1,710.0699999999998,-208.76999999999998,0]],[0,["_lrot"],163,[3,0,0,0,1]],[0,["_euler"],163,[1,0,0,0]]]],148]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-682,[5,"b39APIWzRMR5AN0797wy4+",1,[[6,"RoadItem-140",["_name"],164],[0,["_lpos"],164,[1,755.8399999999998,-208.76999999999998,0]],[0,["_lrot"],164,[3,0,0,0,1]],[0,["_euler"],164,[1,0,0,0]]]],149]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-683,[5,"9dtsP4ncxOMb3DqnArLARk",1,[[6,"RoadItem-141",["_name"],165],[0,["_lpos"],165,[1,801.6099999999998,-208.76999999999998,0]],[0,["_lrot"],165,[3,0,0,0,1]],[0,["_euler"],165,[1,0,0,0]]]],150]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-684,[5,"c8PnzQiUxJr6jfrXgTjI19",1,[[6,"RoadItem-142",["_name"],166],[0,["_lpos"],166,[1,847.3799999999998,-208.76999999999998,0]],[0,["_lrot"],166,[3,0,0,0,1]],[0,["_euler"],166,[1,0,0,0]]]],151]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-685,[5,"f8MsLgJOZPjrR9AzrFl2RW",1,[[6,"RoadItem-143",["_name"],167],[0,["_lpos"],167,[1,893.1499999999997,-208.76999999999998,0]],[0,["_lrot"],167,[3,0,0,0,1]],[0,["_euler"],167,[1,0,0,0]]]],152]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-686,[5,"fcouKMG/xBIZ1p94G3QbO0",1,[[6,"RoadItem-144",["_name"],168],[0,["_lpos"],168,[1,938.9199999999997,-208.76999999999998,0]],[0,["_lrot"],168,[3,0,0,0,1]],[0,["_euler"],168,[1,0,0,0]]]],153]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-687,[5,"e8pNXc3uZJt7Lqm0IZT6Hz",1,[[6,"RoadItem-145",["_name"],169],[0,["_lpos"],169,[1,984.6899999999997,-208.76999999999998,0]],[0,["_lrot"],169,[3,0,0,0,1]],[0,["_euler"],169,[1,0,0,0]]]],154]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-688,[5,"bfWn7NVX5D5oR6NhPehhnV",1,[[6,"RoadItem-146",["_name"],170],[0,["_lpos"],170,[1,1030.4599999999998,-208.76999999999998,0]],[0,["_lrot"],170,[3,0,0,0,1]],[0,["_euler"],170,[1,0,0,0]]]],155]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-689,[5,"36EsTjTiZP5KixkBAxwiq9",1,[[6,"RoadItem-147",["_name"],171],[0,["_lpos"],171,[1,1076.2299999999998,-208.76999999999998,0]],[0,["_lrot"],171,[3,0,0,0,1]],[0,["_euler"],171,[1,0,0,0]]]],156]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-690,[5,"b54PGVXudAXpLE4uX9cInH",1,[[6,"RoadItem-148",["_name"],172],[0,["_lpos"],172,[1,1121.9999999999998,-208.76999999999998,0]],[0,["_lrot"],172,[3,0,0,0,1]],[0,["_euler"],172,[1,0,0,0]]]],157]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-691,[5,"21YRXqXJ5M5ahtfqgQELSH",1,[[6,"RoadItem-149",["_name"],173],[0,["_lpos"],173,[1,1167.7699999999998,-208.76999999999998,0]],[0,["_lrot"],173,[3,0,0,0,1]],[0,["_euler"],173,[1,0,0,0]]]],158]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-692,[5,"2bB60LMyxIEq/cMs8xU0l4",1,[[6,"RoadItem-150",["_name"],174],[0,["_lpos"],174,[1,1213.5399999999997,-208.76999999999998,0]],[0,["_lrot"],174,[3,0,0,0,1]],[0,["_euler"],174,[1,0,0,0]]]],159]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-693,[5,"69woKL94RK9oC3qs2F+sj7",1,[[6,"RoadItem-151",["_name"],175],[0,["_lpos"],175,[1,1259.3099999999997,-208.76999999999998,0]],[0,["_lrot"],175,[3,0,0,0,1]],[0,["_euler"],175,[1,0,0,0]]]],160]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-694,[5,"00iNOipzNADogqfoNaXYyw",1,[[6,"RoadItem-152",["_name"],176],[0,["_lpos"],176,[1,1305.0799999999997,-208.76999999999998,0]],[0,["_lrot"],176,[3,0,0,0,1]],[0,["_euler"],176,[1,0,0,0]]]],161]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-695,[5,"02wIy//FRO+4Yv4LLyhr9R",1,[[6,"RoadItem-153",["_name"],177],[0,["_lpos"],177,[1,1350.8499999999997,-208.76999999999998,0]],[0,["_lrot"],177,[3,0,0,0,1]],[0,["_euler"],177,[1,0,0,0]]]],162]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-696,[5,"d6h9GZZxZDLI5WPDxH4+SX",1,[[6,"RoadItem-154",["_name"],178],[0,["_lpos"],178,[1,1396.6199999999997,-208.76999999999998,0]],[0,["_lrot"],178,[3,0,0,0,1]],[0,["_euler"],178,[1,0,0,0]]]],163]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-697,[5,"03g9eYRzdPpYrPTo+20Zv3",1,[[6,"RoadItem-155",["_name"],179],[0,["_lpos"],179,[1,23.52,-255.07,0]],[0,["_lrot"],179,[3,0,0,0,1]],[0,["_euler"],179,[1,0,0,0]]]],164]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-698,[5,"cahONN0HNMyab4slsk8MCt",1,[[6,"RoadItem-156",["_name"],180],[0,["_lpos"],180,[1,69.28999999999999,-255.07,0]],[0,["_lrot"],180,[3,0,0,0,1]],[0,["_euler"],180,[1,0,0,0]]]],165]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-699,[5,"d0kXgr6ZJHEpZRb1nwN0mf",1,[[6,"RoadItem-157",["_name"],181],[0,["_lpos"],181,[1,115.05999999999999,-255.07,0]],[0,["_lrot"],181,[3,0,0,0,1]],[0,["_euler"],181,[1,0,0,0]]]],166]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-700,[5,"e7a7rC2+5DlaV47nt4Me2Y",1,[[6,"RoadItem-158",["_name"],182],[0,["_lpos"],182,[1,160.83,-255.07,0]],[0,["_lrot"],182,[3,0,0,0,1]],[0,["_euler"],182,[1,0,0,0]]]],167]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-701,[5,"9cSR/1zQJAcKkRSTLEaYD0",1,[[6,"RoadItem-159",["_name"],183],[0,["_lpos"],183,[1,206.60000000000002,-255.07,0]],[0,["_lrot"],183,[3,0,0,0,1]],[0,["_euler"],183,[1,0,0,0]]]],168]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-702,[5,"f17B1syvFDRY8P3sIDBqPH",1,[[6,"RoadItem-160",["_name"],184],[0,["_lpos"],184,[1,252.37000000000003,-255.07,0]],[0,["_lrot"],184,[3,0,0,0,1]],[0,["_euler"],184,[1,0,0,0]]]],169]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-703,[5,"bdRoZXsbNEeasD7dMC1/f1",1,[[6,"RoadItem-161",["_name"],185],[0,["_lpos"],185,[1,298.14,-255.07,0]],[0,["_lrot"],185,[3,0,0,0,1]],[0,["_euler"],185,[1,0,0,0]]]],170]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-704,[5,"4b0bXll3RDWb856Muph+v7",1,[[6,"RoadItem-162",["_name"],186],[0,["_lpos"],186,[1,343.90999999999997,-255.07,0]],[0,["_lrot"],186,[3,0,0,0,1]],[0,["_euler"],186,[1,0,0,0]]]],171]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-705,[5,"b1xEXVDcBOF536uFB01rm6",1,[[6,"RoadItem-163",["_name"],187],[0,["_lpos"],187,[1,389.67999999999995,-255.07,0]],[0,["_lrot"],187,[3,0,0,0,1]],[0,["_euler"],187,[1,0,0,0]]]],172]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-706,[5,"bbDkNTwuRBCrZ26csXGPzd",1,[[6,"RoadItem-164",["_name"],188],[0,["_lpos"],188,[1,435.44999999999993,-255.07,0]],[0,["_lrot"],188,[3,0,0,0,1]],[0,["_euler"],188,[1,0,0,0]]]],173]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-707,[5,"007BRolqRCUZLesiY0eVMx",1,[[6,"RoadItem-165",["_name"],189],[0,["_lpos"],189,[1,481.2199999999999,-255.07,0]],[0,["_lrot"],189,[3,0,0,0,1]],[0,["_euler"],189,[1,0,0,0]]]],174]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-708,[5,"566uaBC8dM6r8y2qzvKd85",1,[[6,"RoadItem-166",["_name"],190],[0,["_lpos"],190,[1,526.9899999999999,-255.07,0]],[0,["_lrot"],190,[3,0,0,0,1]],[0,["_euler"],190,[1,0,0,0]]]],175]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-709,[5,"33GiwrHvlBhagbBdy4AdeE",1,[[6,"RoadItem-167",["_name"],191],[0,["_lpos"],191,[1,572.7599999999999,-255.07,0]],[0,["_lrot"],191,[3,0,0,0,1]],[0,["_euler"],191,[1,0,0,0]]]],176]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-710,[5,"a89oluwBJI/oZYwpJcdxIt",1,[[6,"RoadItem-168",["_name"],192],[0,["_lpos"],192,[1,618.5299999999999,-255.07,0]],[0,["_lrot"],192,[3,0,0,0,1]],[0,["_euler"],192,[1,0,0,0]]]],177]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-711,[5,"94za4R6g1PsIkYMYbyOpYA",1,[[6,"RoadItem-169",["_name"],193],[0,["_lpos"],193,[1,664.2999999999998,-255.07,0]],[0,["_lrot"],193,[3,0,0,0,1]],[0,["_euler"],193,[1,0,0,0]]]],178]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-712,[5,"7adum3CKpOUI4JQ5EFNWWm",1,[[6,"RoadItem-170",["_name"],194],[0,["_lpos"],194,[1,710.0699999999998,-255.07,0]],[0,["_lrot"],194,[3,0,0,0,1]],[0,["_euler"],194,[1,0,0,0]]]],179]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-713,[5,"90rS3Y/1xEd6+e5B63+R83",1,[[6,"RoadItem-171",["_name"],195],[0,["_lpos"],195,[1,755.8399999999998,-255.07,0]],[0,["_lrot"],195,[3,0,0,0,1]],[0,["_euler"],195,[1,0,0,0]]]],180]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-714,[5,"ddOPG0xbNDwL9EwTlR49+T",1,[[6,"RoadItem-172",["_name"],196],[0,["_lpos"],196,[1,801.6099999999998,-255.07,0]],[0,["_lrot"],196,[3,0,0,0,1]],[0,["_euler"],196,[1,0,0,0]]]],181]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-715,[5,"0bTulukzlBT53xwSdn4Cg+",1,[[6,"RoadItem-173",["_name"],197],[0,["_lpos"],197,[1,847.3799999999998,-255.07,0]],[0,["_lrot"],197,[3,0,0,0,1]],[0,["_euler"],197,[1,0,0,0]]]],182]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-716,[5,"94PLd5GrVM6aOfJ1XsI6A/",1,[[6,"RoadItem-174",["_name"],198],[0,["_lpos"],198,[1,893.1499999999997,-255.07,0]],[0,["_lrot"],198,[3,0,0,0,1]],[0,["_euler"],198,[1,0,0,0]]]],183]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-717,[5,"cfe7Ok6iZBx7ZGPRaFEpBu",1,[[6,"RoadItem-175",["_name"],199],[0,["_lpos"],199,[1,938.9199999999997,-255.07,0]],[0,["_lrot"],199,[3,0,0,0,1]],[0,["_euler"],199,[1,0,0,0]]]],184]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-718,[5,"8fhe8CwpBGa51EInsm4BQf",1,[[6,"RoadItem-176",["_name"],200],[0,["_lpos"],200,[1,984.6899999999997,-255.07,0]],[0,["_lrot"],200,[3,0,0,0,1]],[0,["_euler"],200,[1,0,0,0]]]],185]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-719,[5,"a0W52QbmxMd4DUeMBh1vk9",1,[[6,"RoadItem-177",["_name"],201],[0,["_lpos"],201,[1,1030.4599999999998,-255.07,0]],[0,["_lrot"],201,[3,0,0,0,1]],[0,["_euler"],201,[1,0,0,0]]]],186]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-720,[5,"a582Hq2+xGYbb2qWYENDKD",1,[[6,"RoadItem-178",["_name"],202],[0,["_lpos"],202,[1,1076.2299999999998,-255.07,0]],[0,["_lrot"],202,[3,0,0,0,1]],[0,["_euler"],202,[1,0,0,0]]]],187]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-721,[5,"b4q6m+0LZFlYUDXeYkyKDV",1,[[6,"RoadItem-179",["_name"],203],[0,["_lpos"],203,[1,1121.9999999999998,-255.07,0]],[0,["_lrot"],203,[3,0,0,0,1]],[0,["_euler"],203,[1,0,0,0]]]],188]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-722,[5,"7cMCF/vfBFY7S4CKZgv2gI",1,[[6,"RoadItem-180",["_name"],204],[0,["_lpos"],204,[1,1167.7699999999998,-255.07,0]],[0,["_lrot"],204,[3,0,0,0,1]],[0,["_euler"],204,[1,0,0,0]]]],189]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-723,[5,"59r+My505AXo1mCiaDXT9q",1,[[6,"RoadItem-181",["_name"],205],[0,["_lpos"],205,[1,1213.5399999999997,-255.07,0]],[0,["_lrot"],205,[3,0,0,0,1]],[0,["_euler"],205,[1,0,0,0]]]],190]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-724,[5,"0d8iqXTlNC/a2N3hCRa2/2",1,[[6,"RoadItem-182",["_name"],206],[0,["_lpos"],206,[1,1259.3099999999997,-255.07,0]],[0,["_lrot"],206,[3,0,0,0,1]],[0,["_euler"],206,[1,0,0,0]]]],191]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-725,[5,"50FoMSrXtAaoW28PrXf4Rh",1,[[6,"RoadItem-183",["_name"],207],[0,["_lpos"],207,[1,1305.0799999999997,-255.07,0]],[0,["_lrot"],207,[3,0,0,0,1]],[0,["_euler"],207,[1,0,0,0]]]],192]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-726,[5,"dfNAohsbxF97PyXLMowMq2",1,[[6,"RoadItem-184",["_name"],208],[0,["_lpos"],208,[1,1350.8499999999997,-255.07,0]],[0,["_lrot"],208,[3,0,0,0,1]],[0,["_euler"],208,[1,0,0,0]]]],193]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-727,[5,"12bKiL9i1P4oBymKnO5WNa",1,[[6,"RoadItem-185",["_name"],209],[0,["_lpos"],209,[1,1396.6199999999997,-255.07,0]],[0,["_lrot"],209,[3,0,0,0,1]],[0,["_euler"],209,[1,0,0,0]]]],194]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-728,[5,"5f/NruG99HPryJVpj/sQ9T",1,[[6,"RoadItem-186",["_name"],210],[0,["_lpos"],210,[1,23.52,-301.37,0]],[0,["_lrot"],210,[3,0,0,0,1]],[0,["_euler"],210,[1,0,0,0]]]],195]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-729,[5,"ffCrAApaFLyrcCKH/AHBTA",1,[[6,"RoadItem-187",["_name"],211],[0,["_lpos"],211,[1,69.28999999999999,-301.37,0]],[0,["_lrot"],211,[3,0,0,0,1]],[0,["_euler"],211,[1,0,0,0]]]],196]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-730,[5,"11jZW3/s1FYJZB31yz89ol",1,[[6,"RoadItem-188",["_name"],212],[0,["_lpos"],212,[1,115.05999999999999,-301.37,0]],[0,["_lrot"],212,[3,0,0,0,1]],[0,["_euler"],212,[1,0,0,0]]]],197]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-731,[5,"36WqSvIt1ApaGYtyNuV0Km",1,[[6,"RoadItem-189",["_name"],213],[0,["_lpos"],213,[1,160.83,-301.37,0]],[0,["_lrot"],213,[3,0,0,0,1]],[0,["_euler"],213,[1,0,0,0]]]],198]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-732,[5,"d5z9P4v4lDJZU9YKa36s5v",1,[[6,"RoadItem-190",["_name"],214],[0,["_lpos"],214,[1,206.60000000000002,-301.37,0]],[0,["_lrot"],214,[3,0,0,0,1]],[0,["_euler"],214,[1,0,0,0]]]],199]],[3,0,{},2,[4,"d1LLgj3plJr7BgjvhEM8s0",-733,[5,"18yNmeVN9IMr7hDM0ljgt5",1,[[6,"RoadItem-191",["_name"],215],[0,["_lpos"],215,[1,252.37000000000003,-301.37,0]],[0,["_lrot"],215,[3,0,0,0,1]],[0,["_euler"],215,[1,0,0,0]]]],200]],[14,"bg_iattice2",33554432,5,[[10,-734,[2,"e2qu/jl4hBIrAtZuxiueBz"],[5,344.5,139],[0,0,1]],[16,0,-735,[2,"79mofQAiFLEYeK3xixI/cF"],201]],[7,"4fiugwtNZIKqI9H2zNuecd",1,0]],[11,"bg_iattice3",33554432,5,[[10,-736,[2,"0azhfWDylHfJro87V8vkMI"],[5,344.5,139],[0,0,1]],[16,0,-737,[2,"84sTsYrq1KYpxwM3qxBNYG"],202]],[7,"cbJiHPXkNApIjgMVd5cu0I",1,0],[1,343.2,0,0]],[11,"bg_iattice4",33554432,5,[[10,-738,[2,"93jwgdRSNPdrmtoh0a6aJ0"],[5,344.5,139],[0,0,1]],[16,0,-739,[2,"44+J0kUmhCQaKPM4TW4vYJ"],203]],[7,"263LNvIFVE351a8eFRLG75",1,0],[1,686.4000000000001,0,0]],[11,"bg_iattice5",33554432,5,[[10,-740,[2,"57i/lXmwNHCLdNHRuwitU6"],[5,344.5,139],[0,0,1]],[16,0,-741,[2,"60QBVOe5FIbYs3xtQk6LOv"],204]],[7,"9dkSamLcZA85gXzw2bqgCi",1,0],[1,1029.6000000000001,0,0]],[11,"bg_iattice6",33554432,5,[[10,-742,[2,"8aZwqrOotHPoVvN/y2CT+O"],[5,344.5,139],[0,0,1]],[16,0,-743,[2,"e2DtpOWUFALI/9Hr/xy8I+"],205]],[7,"1dwBHPyMxKJ5IIDzSCQmID",1,0],[1,1372.8000000000002,0,0]],[14,"bg_iattice2",33554432,9,[[10,-744,[2,"66nT6Da+1Dn6Y9Y4ICaPlD"],[5,344.5,139],[0,0,1]],[16,0,-745,[2,"d4+zqHUpVN0q4g33hiJi3E"],206]],[7,"0eGg4HrLxJJ5sBFI8F6LL6",1,0]],[11,"bg_iattice3",33554432,9,[[10,-746,[2,"01dWuOyNJDPbrlC6SK0NQD"],[5,344.5,139],[0,0,1]],[16,0,-747,[2,"e2iDA54M5EsYOJN2ruPdpz"],207]],[7,"b56sFIv3lGUKKDXWe5WbrX",1,0],[1,343.2,0,0]],[11,"bg_iattice4",33554432,9,[[10,-748,[2,"56KePI2FZNUohDbDKR2m21"],[5,344.5,139],[0,0,1]],[16,0,-749,[2,"73EWel0MhEhboDVyNiUYd1"],208]],[7,"960fATsgNH2pBVB5lQi9Ck",1,0],[1,686.4000000000001,0,0]],[14,"bg_iattice2",33554432,10,[[10,-750,[2,"9bd5xFjetEaILEEes/5aIf"],[5,344.5,139],[0,0,1]],[16,0,-751,[2,"60S8RKw7dI+4HozYdQm+SF"],209]],[7,"733sMPO2dEe4HuxpHR0ACp",1,0]],[11,"bg_iattice3",33554432,10,[[10,-752,[2,"a3e+YUZJBBy75+E93yXRAK"],[5,344.5,139],[0,0,1]],[16,0,-753,[2,"abwLpV6nVFh5+SXFOuoboj"],210]],[7,"adc6658SdAdpO4SG8d3Y8q",1,0],[1,343.2,0,0]],[11,"bg_iattice4",33554432,10,[[10,-754,[2,"43RtcunztP7LAO8B0MBLfx"],[5,344.5,139],[0,0,1]],[16,0,-755,[2,"f26cyDXjFBF7bqz7q0EhnS"],211]],[7,"40wZbqTVpG54r/FJ4ad64f",1,0],[1,686.4000000000001,0,0]],[11,"Mask",33554432,1,[[8,-756,[2,"aaQXfbx9NIJowUBA+6iBDZ"],[5,1191,1113.224]],[58,0,-757,[2,"9aAZwGfC9MC7O1J0MBxmzg"],[4,4278190080],212]],[7,"05+eGPjcNMp6eB71DF9aOs",1,0],[1,1311,0,0]],[32,"bg_cphroad1_1",33554432,23,[[10,-758,[2,"9cRrcyYyJFrL1YipqMLrKH"],[5,1431,73],[0,0.5,1]],[16,0,-759,[2,"87yCqRVZdJHIej65fhjTET"],222]],[7,"b9t9RijplBLpt78plqsZ7D",1,0],[1,0,540,0],[1,1,1.7,1.7]],[11,"lebelTimer",33554432,23,[[8,-760,[2,"9dHhlbVm9JNImNWWOWXeWu"],[5,389.31,126]],[36,"1234151",100,100,100,-761,[2,"3e2OkIt75EfbIw0Tss8QVe"]]],[7,"434PyiXGND8I0QnHEloeRn",1,0],[1,0,478.131,0]],[11,"Node",33554432,4,[[8,-762,[2,"19eXiOLNBKpaoMseahe0wI"],[5,0,0]]],[7,"8dfi7pNkJNrZ1GezabJn7S",1,0],[1,-715.5,416,0]],[191,11,[2,"48ewTHPrVMu533k8JzU94P"],7,230],[171,null,null,13,[2,"cecOSJgHxFJZJbLITymhso"]],[192,4,[2,"54c3sbkWVI1rtr6LFM6/Vx"],442,443],[59,3,16,[2,"8f9cyaRhBAwpUKuGbr0VEi"]],[193,23,[2,"8dtqeEY8RGpa3bDC8JtUGZ"]]],0,[0,-1,235,0,-2,236,0,-3,237,0,-4,238,0,-5,239,0,-6,240,0,-7,241,0,-8,242,0,-9,243,0,-10,244,0,-11,245,0,-12,246,0,-13,247,0,-14,248,0,-15,249,0,-16,250,0,-17,251,0,-18,252,0,-19,253,0,-20,254,0,-21,255,0,-22,256,0,-23,257,0,-24,258,0,-25,259,0,-26,260,0,-27,261,0,-28,262,0,-29,263,0,-30,264,0,-31,265,0,-32,266,0,-33,267,0,-34,268,0,-35,269,0,-36,270,0,-37,271,0,-38,272,0,-39,273,0,-40,274,0,-41,275,0,-42,276,0,-43,277,0,-44,278,0,-45,279,0,-46,280,0,-47,281,0,-48,282,0,-49,283,0,-50,284,0,-51,285,0,-52,286,0,-53,287,0,-54,288,0,-55,289,0,-56,290,0,-57,291,0,-58,292,0,-59,293,0,-60,294,0,-61,295,0,-62,296,0,-63,297,0,-64,298,0,-65,299,0,-66,300,0,-67,301,0,-68,302,0,-69,303,0,-70,304,0,-71,305,0,-72,306,0,-73,307,0,-74,308,0,-75,309,0,-76,310,0,-77,311,0,-78,312,0,-79,313,0,-80,314,0,-81,315,0,-82,316,0,-83,317,0,-84,318,0,-85,319,0,-86,320,0,-87,321,0,-88,322,0,-89,323,0,-90,324,0,-91,325,0,-92,326,0,-93,327,0,-94,328,0,-95,329,0,-96,330,0,-97,331,0,-98,332,0,-99,333,0,-100,334,0,-101,335,0,-102,336,0,-103,337,0,-104,338,0,-105,339,0,-106,340,0,-107,341,0,-108,342,0,-109,343,0,-110,344,0,-111,345,0,-112,346,0,-113,347,0,-114,348,0,-115,349,0,-116,350,0,-117,351,0,-118,352,0,-119,353,0,-120,354,0,-121,355,0,-122,356,0,-123,357,0,-124,358,0,-125,359,0,-126,360,0,-127,361,0,-128,362,0,-129,363,0,-130,364,0,-131,365,0,-132,366,0,-133,367,0,-134,368,0,-135,369,0,-136,370,0,-137,371,0,-138,372,0,-139,373,0,-140,374,0,-141,375,0,-142,376,0,-143,377,0,-144,378,0,-145,379,0,-146,380,0,-147,381,0,-148,382,0,-149,383,0,-150,384,0,-151,385,0,-152,386,0,-153,387,0,-154,388,0,-155,389,0,-156,390,0,-157,391,0,-158,392,0,-159,393,0,-160,394,0,-161,395,0,-162,396,0,-163,397,0,-164,398,0,-165,399,0,-166,400,0,-167,401,0,-168,402,0,-169,403,0,-170,404,0,-171,405,0,-172,406,0,-173,407,0,-174,408,0,-175,409,0,-176,410,0,-177,411,0,-178,412,0,-179,413,0,-180,414,0,-181,415,0,-182,416,0,-183,417,0,-184,418,0,-185,419,0,-186,420,0,-187,421,0,-188,422,0,-189,423,0,-190,424,0,-191,425,0,-192,426,0,-193,17,0,-194,18,0,-195,19,0,-196,20,0,-197,21,0,-198,22,0,5,17,0,9,3,0,5,18,0,9,3,0,5,19,0,9,3,0,5,20,0,9,3,0,5,21,0,9,3,0,5,22,0,9,3,0,5,17,0,9,3,0,5,18,0,9,3,0,5,19,0,9,3,0,5,20,0,9,3,0,5,21,0,9,3,0,5,22,0,9,3,0,1,1,0,0,1,0,40,446,0,41,3,0,42,444,0,0,1,0,-1,4,0,-2,438,0,-3,15,0,-4,23,0,0,2,0,0,2,0,-1,235,0,-2,236,0,-3,237,0,-4,238,0,-5,239,0,-6,240,0,-7,241,0,-8,242,0,-9,243,0,-10,244,0,-11,245,0,-12,246,0,-13,247,0,-14,248,0,-15,249,0,-16,250,0,-17,251,0,-18,252,0,-19,253,0,-20,254,0,-21,255,0,-22,256,0,-23,257,0,-24,258,0,-25,259,0,-26,260,0,-27,261,0,-28,262,0,-29,263,0,-30,264,0,-31,265,0,-32,266,0,-33,267,0,-34,268,0,-35,269,0,-36,270,0,-37,271,0,-38,272,0,-39,273,0,-40,274,0,-41,275,0,-42,276,0,-43,277,0,-44,278,0,-45,279,0,-46,280,0,-47,281,0,-48,282,0,-49,283,0,-50,284,0,-51,285,0,-52,286,0,-53,287,0,-54,288,0,-55,289,0,-56,290,0,-57,291,0,-58,292,0,-59,293,0,-60,294,0,-61,295,0,-62,296,0,-63,297,0,-64,298,0,-65,299,0,-66,300,0,-67,301,0,-68,302,0,-69,303,0,-70,304,0,-71,305,0,-72,306,0,-73,307,0,-74,308,0,-75,309,0,-76,310,0,-77,311,0,-78,312,0,-79,313,0,-80,314,0,-81,315,0,-82,316,0,-83,317,0,-84,318,0,-85,319,0,-86,320,0,-87,321,0,-88,322,0,-89,323,0,-90,324,0,-91,325,0,-92,326,0,-93,327,0,-94,328,0,-95,329,0,-96,330,0,-97,331,0,-98,332,0,-99,333,0,-100,334,0,-101,335,0,-102,336,0,-103,337,0,-104,338,0,-105,339,0,-106,340,0,-107,341,0,-108,342,0,-109,343,0,-110,344,0,-111,345,0,-112,346,0,-113,347,0,-114,348,0,-115,349,0,-116,350,0,-117,351,0,-118,352,0,-119,353,0,-120,354,0,-121,355,0,-122,356,0,-123,357,0,-124,358,0,-125,359,0,-126,360,0,-127,361,0,-128,362,0,-129,363,0,-130,364,0,-131,365,0,-132,366,0,-133,367,0,-134,368,0,-135,369,0,-136,370,0,-137,371,0,-138,372,0,-139,373,0,-140,374,0,-141,375,0,-142,376,0,-143,377,0,-144,378,0,-145,379,0,-146,380,0,-147,381,0,-148,382,0,-149,383,0,-150,384,0,-151,385,0,-152,386,0,-153,387,0,-154,388,0,-155,389,0,-156,390,0,-157,391,0,-158,392,0,-159,393,0,-160,394,0,-161,395,0,-162,396,0,-163,397,0,-164,398,0,-165,399,0,-166,400,0,-167,401,0,-168,402,0,-169,403,0,-170,404,0,-171,405,0,-172,406,0,-173,407,0,-174,408,0,-175,409,0,-176,410,0,-177,411,0,-178,412,0,-179,413,0,-180,414,0,-181,415,0,-182,416,0,-183,417,0,-184,418,0,-185,419,0,-186,420,0,-187,421,0,-188,422,0,-189,423,0,-190,424,0,-191,425,0,-192,426,0,0,4,0,-2,444,0,-1,224,0,-2,225,0,-3,226,0,-4,441,0,-5,11,0,-6,13,0,-7,216,0,-8,218,0,-9,220,0,0,5,0,0,5,0,-1,427,0,-2,428,0,-3,429,0,-4,430,0,-5,431,0,0,6,0,0,6,0,-1,17,0,-2,18,0,-3,19,0,-4,20,0,-5,21,0,-6,22,0,0,7,0,0,7,0,-1,227,0,-2,228,0,-3,229,0,0,8,0,0,8,0,-1,231,0,-2,232,0,-3,233,0,0,9,0,0,9,0,-1,432,0,-2,433,0,-3,434,0,0,10,0,0,10,0,-1,435,0,-2,436,0,-3,437,0,0,11,0,0,11,0,-3,442,0,-1,12,0,0,12,0,0,12,0,-2,230,0,0,13,0,0,13,0,-3,443,0,-1,14,0,0,14,0,0,14,0,-2,234,0,0,15,0,-1,222,0,0,16,0,0,16,0,-3,445,0,-1,223,0,1,17,0,1,18,0,1,19,0,1,20,0,1,21,0,1,22,0,0,23,0,-2,446,0,-1,439,0,-2,440,0,0,216,0,0,216,0,-1,217,0,0,217,0,0,217,0,0,218,0,0,218,0,-1,219,0,0,219,0,0,219,0,0,220,0,0,220,0,-1,221,0,0,221,0,0,221,0,0,222,0,0,222,0,0,223,0,0,223,0,0,224,0,0,224,0,0,225,0,0,225,0,0,226,0,0,226,0,0,227,0,0,227,0,0,228,0,0,228,0,0,229,0,0,229,0,0,230,0,0,231,0,0,231,0,0,232,0,0,232,0,0,233,0,0,233,0,0,234,0,1,235,0,1,236,0,1,237,0,1,238,0,1,239,0,1,240,0,1,241,0,1,242,0,1,243,0,1,244,0,1,245,0,1,246,0,1,247,0,1,248,0,1,249,0,1,250,0,1,251,0,1,252,0,1,253,0,1,254,0,1,255,0,1,256,0,1,257,0,1,258,0,1,259,0,1,260,0,1,261,0,1,262,0,1,263,0,1,264,0,1,265,0,1,266,0,1,267,0,1,268,0,1,269,0,1,270,0,1,271,0,1,272,0,1,273,0,1,274,0,1,275,0,1,276,0,1,277,0,1,278,0,1,279,0,1,280,0,1,281,0,1,282,0,1,283,0,1,284,0,1,285,0,1,286,0,1,287,0,1,288,0,1,289,0,1,290,0,1,291,0,1,292,0,1,293,0,1,294,0,1,295,0,1,296,0,1,297,0,1,298,0,1,299,0,1,300,0,1,301,0,1,302,0,1,303,0,1,304,0,1,305,0,1,306,0,1,307,0,1,308,0,1,309,0,1,310,0,1,311,0,1,312,0,1,313,0,1,314,0,1,315,0,1,316,0,1,317,0,1,318,0,1,319,0,1,320,0,1,321,0,1,322,0,1,323,0,1,324,0,1,325,0,1,326,0,1,327,0,1,328,0,1,329,0,1,330,0,1,331,0,1,332,0,1,333,0,1,334,0,1,335,0,1,336,0,1,337,0,1,338,0,1,339,0,1,340,0,1,341,0,1,342,0,1,343,0,1,344,0,1,345,0,1,346,0,1,347,0,1,348,0,1,349,0,1,350,0,1,351,0,1,352,0,1,353,0,1,354,0,1,355,0,1,356,0,1,357,0,1,358,0,1,359,0,1,360,0,1,361,0,1,362,0,1,363,0,1,364,0,1,365,0,1,366,0,1,367,0,1,368,0,1,369,0,1,370,0,1,371,0,1,372,0,1,373,0,1,374,0,1,375,0,1,376,0,1,377,0,1,378,0,1,379,0,1,380,0,1,381,0,1,382,0,1,383,0,1,384,0,1,385,0,1,386,0,1,387,0,1,388,0,1,389,0,1,390,0,1,391,0,1,392,0,1,393,0,1,394,0,1,395,0,1,396,0,1,397,0,1,398,0,1,399,0,1,400,0,1,401,0,1,402,0,1,403,0,1,404,0,1,405,0,1,406,0,1,407,0,1,408,0,1,409,0,1,410,0,1,411,0,1,412,0,1,413,0,1,414,0,1,415,0,1,416,0,1,417,0,1,418,0,1,419,0,1,420,0,1,421,0,1,422,0,1,423,0,1,424,0,1,425,0,1,426,0,0,427,0,0,427,0,0,428,0,0,428,0,0,429,0,0,429,0,0,430,0,0,430,0,0,431,0,0,431,0,0,432,0,0,432,0,0,433,0,0,433,0,0,434,0,0,434,0,0,435,0,0,435,0,0,436,0,0,436,0,0,437,0,0,437,0,0,438,0,0,438,0,0,439,0,0,439,0,0,440,0,0,440,0,0,441,0,8,1,2,10,234,3,43,223,3,44,445,3,0,15,5,10,217,6,10,15,7,10,12,8,10,14,9,10,219,10,10,221,16,10,222,762],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,444,445,3],[3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,3,45,6,46],[93,19,19,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,8,94,20,95,3,3,3,3,3,3,96,0,20,3]],[[[18,"UIBetFunctionButton"],[19,"UIBetFunctionButton",33554432,[-7,-8],[[17,-2,[2,"71adv8x+NGI7QKQS6fk/Kg"]],[39,-3,[2,"87ttxq0tNMe5mMs0+v0jsO"]],[194,-6,[2,"0arRrLW7FPAZ+Vrchn0LyH"],-5,-4]],[7,"8fe3u7WjhHkIbsSZh4Gvyc",-1,0]],[41,"ClearCoin",33554432,1,[-10,-11],[[17,-9,[2,"dfkKcaah9BuKwsvanJOtjb"]]],[7,"e3NnFhyf5HxpYS0O6AaRma",1,0],[1,-591.651,-144.84199999999998,0]],[54,"Button",33554432,2,[[[8,-12,[2,"adLZMCJr1P8LURwrZ4NS0G"],[5,90,90]],[15,-13,[2,"9aRHxIZhBI2oUnKMH/g4mM"],0],-14],4,4,1],[7,"10/TV+1TRHXIrtW2e5LzCx",1,0]],[114,"ReferLastBet",false,33554432,1,[-16,-17],[[17,-15,[2,"b8Y8hV3SNBKKq01SNNyIAf"]]],[7,"7eFzGLumpH25BESCrE5ef0",1,0],[1,591.651,-144.842,0]],[54,"Button",33554432,4,[[[8,-18,[2,"0bfCcOkfpH1IX9BxrrjTrY"],[5,90,90]],[15,-19,[2,"a3I184wKNDqYGopFeOYu9l"],1],-20],4,4,1],[7,"f6RebyzdFO17cA3EuXd4uI",1,0]],[11,"LabelText",33554432,2,[[8,-21,[2,"76HyFrmeRP7r3Y1nf+LCfy"],[5,60,50.4]],[42,"撤銷",30,30,-22,[2,"b1PJaVggJKyo+6qN8LmqAN"]]],[7,"85lMALoUhIYZxQmO0z+O49",1,0],[1,0.691,-69.742,0]],[11,"LabelText",33554432,4,[[8,-23,[2,"0eYsueKElG/oH+XQNvYt/r"],[5,150,50.4]],[42,"參照上一把",30,30,-24,[2,"f0NTUUSUtMvKpNuZJ2RNwX"]]],[7,"07HrtD/9FCyZd/2Mchcphr",1,0],[1,0.691,-69.742,0]],[59,1,3,[2,"04h9hw3bJJ3LfrMqoQa5az"]],[59,1,5,[2,"85taK1BgxKbp1aCn+3x2G8"]]],0,[0,1,1,0,0,1,0,0,1,0,47,9,0,48,8,0,0,1,0,-1,2,0,-2,4,0,0,2,0,-1,3,0,-2,6,0,0,3,0,0,3,0,-3,8,0,0,4,0,-1,5,0,-2,7,0,0,5,0,0,5,0,-3,9,0,0,6,0,0,6,0,0,7,0,0,7,0,8,1,24],[0,0,8,9],[3,3,6,6],[12,12,12,12]],[[[195,[[196,"ShadowFlow",[[197,"ShadowStage"]]],[198,"ForwardFlow",1,[[199,"ForwardStage",[[200,["default"]],[201,true,1,["default"]]]]]]]]],0,0,[],[],[]],[[[18,"PanelTimer"],[19,"PanelTimer",33554432,[-6,-7],[[8,-2,[2,"28JrpjYGlAdr6YDuF1vV+B"],[5,0,0]],[202,-5,[2,"e7NpCFR4BOT7Cg4JEhMgJl"],-4,-3]],[7,"96YvkyX2hOHooFOW7xBLSy",-1,0]],[20,"LabelTime",33554432,1,[[[8,-8,[2,"2bfVkbr4lCNIx6dSVsBs2g"],[5,165.16,100.8]],-9],4,1],[7,"a0ZUAd/rlHJYhuXq9VKdq5",1,0],[1,0.9550000000000409,299.03600000000006,0]],[20,"LabelState",33554432,1,[[[8,-10,[2,"deKjuSMkVECINtMzv2PNt+"],[5,169.24,100.8]],-11],4,1],[7,"4eH9z7goRCp6Jfpnz9219K",1,0],[1,0,242.452,0]],[36,"00:15",66,66,80,2,[2,"e2cMmdAjJNXahLJQ2r8qXh"]],[36,"PLEASEBET",29,29,80,3,[2,"35G88sPXpAeK9m3y1tlYxI"]]],0,[0,1,1,0,0,1,0,49,5,0,50,4,0,0,1,0,-1,2,0,-2,3,0,0,2,0,-2,4,0,0,3,0,-2,5,0,8,1,11],[],[],[]]]]
